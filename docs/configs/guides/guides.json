[
  {
    "content": "\n## Introduction\n\nThis tutorial teaches you how to create an automated web3 telegram bot that listens to blockchain events and sends real-time notifications.\n\nWe will use node-telegram-bot-api, express and Moralis Streams API.\n\n### YouTube Tutorial\n\nhttps://www.youtube.com/watch?v=0Kr1523SfCw\n\n## Project Setup\n\nThis section is split in multiple steps that you can follow. Let's dive in.\n\nYou can find the repository with the final code here: [Github](https://github.com/MoralisWeb3/youtube-tutorials/tree/main/automated-telegram-nft-transfer-bot/).\n\n1. ### Create a folder and initiate a project using the package manager of your choice.\n\n```bash npm2yarn\nnpm init -y\n```\n\nThis will initiate the project and create a `package.json` file containing the following:\n\n```json package.json\n{\n  \"name\": \"backend\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  \"keywords\": [],\n  \"author\": \"\",\n  \"license\": \"ISC\"\n}\n```\n\n2. ### Install the required dependencies.\n\n```bash npm2yarn\nnpm install express node-telegram-bot-api dotenv nodemon\n```\n\n3. ### Create an `index.js` file containing our express endpoint.\n\n```javascript index.js\nrequire(\"dotenv\").config();\nconst express = require(\"express\");\nconst TelegramBot = require(\"node-telegram-bot-api\");\nconst app = express();\nconst port = 5001;\n\nconst TELEGRAM_BOT_TOKEN = process.env.TELEGRAM_BOT_TOKEN;\n\nconst bot = new TelegramBot(TELEGRAM_BOT_TOKEN, { polling: true });\n\napp.use(express.json());\n\napp.post(\"/webhook\", async (req, res) => {\n  const webhook = req.body;\n\n  for (const nftTransfer of webhook.nftTransfers) {\n    const fromAddress = `From address: ${nftTransfer.from.slice(\n      0,\n      4\n    )}...${nftTransfer.from.slice(38)}`;\n    const toAddress = `To address: ${nftTransfer.to.slice(\n      0,\n      4\n    )}...${nftTransfer.to.slice(38)}`;\n    const tokenItem = `Token Item: ${nftTransfer.tokenName} #${nftTransfer.tokenId}`;\n    const transactionHash = `Transaction Hash: ${nftTransfer.transactionHash}`;\n\n    const chatId = \"ADD-CHAT-ID-FROM-LATER-STEPS\";\n    const text = `${fromAddress}, ${toAddress}, ${tokenItem}, ${transactionHash}`;\n\n    bot.sendMessage(chatId, text);\n  }\n\n  return res.status(200).json();\n});\n\napp.listen(port, () => {\n  console.log(`Listening for NFT Transfers`);\n});\n```\n\n4. ### Setup an `ngrok` tunnel to our express app that will be running locally\n\n- Install `ngrok`.\n\n```shell Shell\nnpm i -g ngrok\n```\n\n- In a new terminal window run `ngrok http` to create a tunnel to our express app using the same port that we specified inside `index.js`\n\n```shell Shell\nngrok http 5001\n```\n\nThis will give us an address where out express app will be running and where we can setup webhooks for streams api.\n\n![](/img/content/c2b72e9-Screenshot_2022-11-24_at_15.24.44.webp)\n\n5. ### Start our express server.\n\nBack inside `package.json` add a start script that will start our express app and reload when we make changes.\n\n```json package.json\n{\n  \"name\": \"backend\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"start\": \"nodemon index.js\",\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  \"keywords\": [],\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"dependencies\": {\n    \"dotenv\": \"^16.0.3\",\n    \"express\": \"^4.18.2\",\n    \"ngrok\": \"^4.3.3\",\n    \"node-telegram-bot-api\": \"^0.60.0\",\n    \"nodemon\": \"^2.0.20\"\n  }\n}\n```\n\nRun the start command.\n\n```bash npm2yarn\nnpm run start\n```\n\n## Streams Setup\n\nWe will use Moralis Streams API to get real-time events and send notifications\n\nInside our admin panel access [streams section](https://admin.moralis.io/streams) and create a new stream.\n\n![](/img/content/step1.webp)\n\nSelect **Create It From Admin**\n\n![](/img/content/step2.webp)\n\nFor this example we will use the Doodles NFT smart contract, but you can use any smart contract of your choice:\n\n- Contract Address : `0x8a90CAb2b38dba80c64b7734e58Ee1dB38B8992e`\n- Abi:\n  ```json Abi\n  [\n    { \"inputs\": [], \"stateMutability\": \"nonpayable\", \"type\": \"constructor\" },\n    {\n      \"anonymous\": false,\n      \"inputs\": [\n        {\n          \"indexed\": true,\n          \"internalType\": \"address\",\n          \"name\": \"owner\",\n          \"type\": \"address\"\n        },\n        {\n          \"indexed\": true,\n          \"internalType\": \"address\",\n          \"name\": \"approved\",\n          \"type\": \"address\"\n        },\n        {\n          \"indexed\": true,\n          \"internalType\": \"uint256\",\n          \"name\": \"tokenId\",\n          \"type\": \"uint256\"\n        }\n      ],\n      \"name\": \"Approval\",\n      \"type\": \"event\"\n    },\n    {\n      \"anonymous\": false,\n      \"inputs\": [\n        {\n          \"indexed\": true,\n          \"internalType\": \"address\",\n          \"name\": \"owner\",\n          \"type\": \"address\"\n        },\n        {\n          \"indexed\": true,\n          \"internalType\": \"address\",\n          \"name\": \"operator\",\n          \"type\": \"address\"\n        },\n        {\n          \"indexed\": false,\n          \"internalType\": \"bool\",\n          \"name\": \"approved\",\n          \"type\": \"bool\"\n        }\n      ],\n      \"name\": \"ApprovalForAll\",\n      \"type\": \"event\"\n    },\n    {\n      \"anonymous\": false,\n      \"inputs\": [\n        {\n          \"indexed\": true,\n          \"internalType\": \"address\",\n          \"name\": \"previousOwner\",\n          \"type\": \"address\"\n        },\n        {\n          \"indexed\": true,\n          \"internalType\": \"address\",\n          \"name\": \"newOwner\",\n          \"type\": \"address\"\n        }\n      ],\n      \"name\": \"OwnershipTransferred\",\n      \"type\": \"event\"\n    },\n    {\n      \"anonymous\": false,\n      \"inputs\": [\n        {\n          \"indexed\": true,\n          \"internalType\": \"address\",\n          \"name\": \"from\",\n          \"type\": \"address\"\n        },\n        {\n          \"indexed\": true,\n          \"internalType\": \"address\",\n          \"name\": \"to\",\n          \"type\": \"address\"\n        },\n        {\n          \"indexed\": true,\n          \"internalType\": \"uint256\",\n          \"name\": \"tokenId\",\n          \"type\": \"uint256\"\n        }\n      ],\n      \"name\": \"Transfer\",\n      \"type\": \"event\"\n    },\n    {\n      \"inputs\": [],\n      \"name\": \"MAX_PUBLIC_MINT\",\n      \"outputs\": [{ \"internalType\": \"uint256\", \"name\": \"\", \"type\": \"uint256\" }],\n      \"stateMutability\": \"view\",\n      \"type\": \"function\"\n    },\n    {\n      \"inputs\": [],\n      \"name\": \"MAX_SUPPLY\",\n      \"outputs\": [{ \"internalType\": \"uint256\", \"name\": \"\", \"type\": \"uint256\" }],\n      \"stateMutability\": \"view\",\n      \"type\": \"function\"\n    },\n    {\n      \"inputs\": [],\n      \"name\": \"PRICE_PER_TOKEN\",\n      \"outputs\": [{ \"internalType\": \"uint256\", \"name\": \"\", \"type\": \"uint256\" }],\n      \"stateMutability\": \"view\",\n      \"type\": \"function\"\n    },\n    {\n      \"inputs\": [],\n      \"name\": \"PROVENANCE\",\n      \"outputs\": [{ \"internalType\": \"string\", \"name\": \"\", \"type\": \"string\" }],\n      \"stateMutability\": \"view\",\n      \"type\": \"function\"\n    },\n    {\n      \"inputs\": [\n        { \"internalType\": \"address\", \"name\": \"to\", \"type\": \"address\" },\n        { \"internalType\": \"uint256\", \"name\": \"tokenId\", \"type\": \"uint256\" }\n      ],\n      \"name\": \"approve\",\n      \"outputs\": [],\n      \"stateMutability\": \"nonpayable\",\n      \"type\": \"function\"\n    },\n    {\n      \"inputs\": [\n        { \"internalType\": \"address\", \"name\": \"owner\", \"type\": \"address\" }\n      ],\n      \"name\": \"balanceOf\",\n      \"outputs\": [{ \"internalType\": \"uint256\", \"name\": \"\", \"type\": \"uint256\" }],\n      \"stateMutability\": \"view\",\n      \"type\": \"function\"\n    },\n    {\n      \"inputs\": [\n        { \"internalType\": \"uint256\", \"name\": \"tokenId\", \"type\": \"uint256\" }\n      ],\n      \"name\": \"getApproved\",\n      \"outputs\": [{ \"internalType\": \"address\", \"name\": \"\", \"type\": \"address\" }],\n      \"stateMutability\": \"view\",\n      \"type\": \"function\"\n    },\n    {\n      \"inputs\": [],\n      \"name\": \"isAllowListActive\",\n      \"outputs\": [{ \"internalType\": \"bool\", \"name\": \"\", \"type\": \"bool\" }],\n      \"stateMutability\": \"view\",\n      \"type\": \"function\"\n    },\n    {\n      \"inputs\": [\n        { \"internalType\": \"address\", \"name\": \"owner\", \"type\": \"address\" },\n        { \"internalType\": \"address\", \"name\": \"operator\", \"type\": \"address\" }\n      ],\n      \"name\": \"isApprovedForAll\",\n      \"outputs\": [{ \"internalType\": \"bool\", \"name\": \"\", \"type\": \"bool\" }],\n      \"stateMutability\": \"view\",\n      \"type\": \"function\"\n    },\n    {\n      \"inputs\": [\n        {\n          \"internalType\": \"uint256\",\n          \"name\": \"numberOfTokens\",\n          \"type\": \"uint256\"\n        }\n      ],\n      \"name\": \"mint\",\n      \"outputs\": [],\n      \"stateMutability\": \"payable\",\n      \"type\": \"function\"\n    },\n    {\n      \"inputs\": [\n        { \"internalType\": \"uint8\", \"name\": \"numberOfTokens\", \"type\": \"uint8\" }\n      ],\n      \"name\": \"mintAllowList\",\n      \"outputs\": [],\n      \"stateMutability\": \"payable\",\n      \"type\": \"function\"\n    },\n    {\n      \"inputs\": [],\n      \"name\": \"name\",\n      \"outputs\": [{ \"internalType\": \"string\", \"name\": \"\", \"type\": \"string\" }],\n      \"stateMutability\": \"view\",\n      \"type\": \"function\"\n    },\n    {\n      \"inputs\": [\n        { \"internalType\": \"address\", \"name\": \"addr\", \"type\": \"address\" }\n      ],\n      \"name\": \"numAvailableToMint\",\n      \"outputs\": [{ \"internalType\": \"uint8\", \"name\": \"\", \"type\": \"uint8\" }],\n      \"stateMutability\": \"view\",\n      \"type\": \"function\"\n    },\n    {\n      \"inputs\": [],\n      \"name\": \"owner\",\n      \"outputs\": [{ \"internalType\": \"address\", \"name\": \"\", \"type\": \"address\" }],\n      \"stateMutability\": \"view\",\n      \"type\": \"function\"\n    },\n    {\n      \"inputs\": [\n        { \"internalType\": \"uint256\", \"name\": \"tokenId\", \"type\": \"uint256\" }\n      ],\n      \"name\": \"ownerOf\",\n      \"outputs\": [{ \"internalType\": \"address\", \"name\": \"\", \"type\": \"address\" }],\n      \"stateMutability\": \"view\",\n      \"type\": \"function\"\n    },\n    {\n      \"inputs\": [],\n      \"name\": \"renounceOwnership\",\n      \"outputs\": [],\n      \"stateMutability\": \"nonpayable\",\n      \"type\": \"function\"\n    },\n    {\n      \"inputs\": [{ \"internalType\": \"uint256\", \"name\": \"n\", \"type\": \"uint256\" }],\n      \"name\": \"reserve\",\n      \"outputs\": [],\n      \"stateMutability\": \"nonpayable\",\n      \"type\": \"function\"\n    },\n    {\n      \"inputs\": [\n        { \"internalType\": \"address\", \"name\": \"from\", \"type\": \"address\" },\n        { \"internalType\": \"address\", \"name\": \"to\", \"type\": \"address\" },\n        { \"internalType\": \"uint256\", \"name\": \"tokenId\", \"type\": \"uint256\" }\n      ],\n      \"name\": \"safeTransferFrom\",\n      \"outputs\": [],\n      \"stateMutability\": \"nonpayable\",\n      \"type\": \"function\"\n    },\n    {\n      \"inputs\": [\n        { \"internalType\": \"address\", \"name\": \"from\", \"type\": \"address\" },\n        { \"internalType\": \"address\", \"name\": \"to\", \"type\": \"address\" },\n        { \"internalType\": \"uint256\", \"name\": \"tokenId\", \"type\": \"uint256\" },\n        { \"internalType\": \"bytes\", \"name\": \"_data\", \"type\": \"bytes\" }\n      ],\n      \"name\": \"safeTransferFrom\",\n      \"outputs\": [],\n      \"stateMutability\": \"nonpayable\",\n      \"type\": \"function\"\n    },\n    {\n      \"inputs\": [],\n      \"name\": \"saleIsActive\",\n      \"outputs\": [{ \"internalType\": \"bool\", \"name\": \"\", \"type\": \"bool\" }],\n      \"stateMutability\": \"view\",\n      \"type\": \"function\"\n    },\n    {\n      \"inputs\": [\n        {\n          \"internalType\": \"address[]\",\n          \"name\": \"addresses\",\n          \"type\": \"address[]\"\n        },\n        { \"internalType\": \"uint8\", \"name\": \"numAllowedToMint\", \"type\": \"uint8\" }\n      ],\n      \"name\": \"setAllowList\",\n      \"outputs\": [],\n      \"stateMutability\": \"nonpayable\",\n      \"type\": \"function\"\n    },\n    {\n      \"inputs\": [\n        { \"internalType\": \"address\", \"name\": \"operator\", \"type\": \"address\" },\n        { \"internalType\": \"bool\", \"name\": \"approved\", \"type\": \"bool\" }\n      ],\n      \"name\": \"setApprovalForAll\",\n      \"outputs\": [],\n      \"stateMutability\": \"nonpayable\",\n      \"type\": \"function\"\n    },\n    {\n      \"inputs\": [\n        { \"internalType\": \"string\", \"name\": \"baseURI_\", \"type\": \"string\" }\n      ],\n      \"name\": \"setBaseURI\",\n      \"outputs\": [],\n      \"stateMutability\": \"nonpayable\",\n      \"type\": \"function\"\n    },\n    {\n      \"inputs\": [\n        { \"internalType\": \"bool\", \"name\": \"_isAllowListActive\", \"type\": \"bool\" }\n      ],\n      \"name\": \"setIsAllowListActive\",\n      \"outputs\": [],\n      \"stateMutability\": \"nonpayable\",\n      \"type\": \"function\"\n    },\n    {\n      \"inputs\": [\n        { \"internalType\": \"string\", \"name\": \"provenance\", \"type\": \"string\" }\n      ],\n      \"name\": \"setProvenance\",\n      \"outputs\": [],\n      \"stateMutability\": \"nonpayable\",\n      \"type\": \"function\"\n    },\n    {\n      \"inputs\": [\n        { \"internalType\": \"bool\", \"name\": \"newState\", \"type\": \"bool\" }\n      ],\n      \"name\": \"setSaleState\",\n      \"outputs\": [],\n      \"stateMutability\": \"nonpayable\",\n      \"type\": \"function\"\n    },\n    {\n      \"inputs\": [\n        { \"internalType\": \"bytes4\", \"name\": \"interfaceId\", \"type\": \"bytes4\" }\n      ],\n      \"name\": \"supportsInterface\",\n      \"outputs\": [{ \"internalType\": \"bool\", \"name\": \"\", \"type\": \"bool\" }],\n      \"stateMutability\": \"view\",\n      \"type\": \"function\"\n    },\n    {\n      \"inputs\": [],\n      \"name\": \"symbol\",\n      \"outputs\": [{ \"internalType\": \"string\", \"name\": \"\", \"type\": \"string\" }],\n      \"stateMutability\": \"view\",\n      \"type\": \"function\"\n    },\n    {\n      \"inputs\": [\n        { \"internalType\": \"uint256\", \"name\": \"index\", \"type\": \"uint256\" }\n      ],\n      \"name\": \"tokenByIndex\",\n      \"outputs\": [{ \"internalType\": \"uint256\", \"name\": \"\", \"type\": \"uint256\" }],\n      \"stateMutability\": \"view\",\n      \"type\": \"function\"\n    },\n    {\n      \"inputs\": [\n        { \"internalType\": \"address\", \"name\": \"owner\", \"type\": \"address\" },\n        { \"internalType\": \"uint256\", \"name\": \"index\", \"type\": \"uint256\" }\n      ],\n      \"name\": \"tokenOfOwnerByIndex\",\n      \"outputs\": [{ \"internalType\": \"uint256\", \"name\": \"\", \"type\": \"uint256\" }],\n      \"stateMutability\": \"view\",\n      \"type\": \"function\"\n    },\n    {\n      \"inputs\": [\n        { \"internalType\": \"uint256\", \"name\": \"tokenId\", \"type\": \"uint256\" }\n      ],\n      \"name\": \"tokenURI\",\n      \"outputs\": [{ \"internalType\": \"string\", \"name\": \"\", \"type\": \"string\" }],\n      \"stateMutability\": \"view\",\n      \"type\": \"function\"\n    },\n    {\n      \"inputs\": [],\n      \"name\": \"totalSupply\",\n      \"outputs\": [{ \"internalType\": \"uint256\", \"name\": \"\", \"type\": \"uint256\" }],\n      \"stateMutability\": \"view\",\n      \"type\": \"function\"\n    },\n    {\n      \"inputs\": [\n        { \"internalType\": \"address\", \"name\": \"from\", \"type\": \"address\" },\n        { \"internalType\": \"address\", \"name\": \"to\", \"type\": \"address\" },\n        { \"internalType\": \"uint256\", \"name\": \"tokenId\", \"type\": \"uint256\" }\n      ],\n      \"name\": \"transferFrom\",\n      \"outputs\": [],\n      \"stateMutability\": \"nonpayable\",\n      \"type\": \"function\"\n    },\n    {\n      \"inputs\": [\n        { \"internalType\": \"address\", \"name\": \"newOwner\", \"type\": \"address\" }\n      ],\n      \"name\": \"transferOwnership\",\n      \"outputs\": [],\n      \"stateMutability\": \"nonpayable\",\n      \"type\": \"function\"\n    },\n    {\n      \"inputs\": [],\n      \"name\": \"withdraw\",\n      \"outputs\": [],\n      \"stateMutability\": \"nonpayable\",\n      \"type\": \"function\"\n    }\n  ]\n  ```\n\nFor the webhook url have to use the url provided previously by ngrok, followed by our `/webhook` endpoint from our express app\n\n![](/img/content/Screenshot_2023-01-11_at_10.11.50.webp)\n\nOur contract is deployed on Ethereum mainnet, so here you will select the network that your smart contract is deployed on:\nAnd also select contract interactions.\n\n![](/img/content/step4.webp)\n\nNext we check Event Emittance, then we have to add the ABI and select the topic we want to stream.\n\n![](/img/content/step5.webp)\n\n## Telegram Bot Setup\n\nWe will now begin to setup our bot to send notifications to our telegram channel.\n\n1. Open Telegram and start a new chat with BotFather.\n\n![](/img/content/Screenshot_2023-01-11_at_09.49.11.webp)\n\n2. Create e new bot by clicking the /newbot.\n\n![](/img/content/Screenshot_2023-01-11_at_09.49.32.webp)\n\n3. Add a name and username for your bot. Copy the access token and paste that in your `.env` file.\n\n![](/img/content/Screenshot_2023-01-11_at_09.50.34.webp)\n\n4. Create a new channel and add your bot as an Administrator.\n\n![](/img/content/Screenshot_2023-01-11_at_09.52.40.webp)\n\n5. Open up your browser and go to this endpoint `https://api.telegram.org/bot/YOUR-TELEGRAM-BOT-API-KEY/getUpdates`, but replace the sample text with the access token we previously copied.\n   If you see this message:\n\n```\n{\n  \"ok\": true,\n  \"result\": []\n}\n```\n\nIt means you should shut down your server, send a message in the newly created channel, and then refresh this page and get this view instead.\n\n```\n{\n  \"ok\": true,\n  \"result\": [\n    {\n      \"update_id\": 596287107,\n      \"channel_post\": {\n        \"message_id\": 3,\n        \"sender_chat\": {\n          \"id\": -1001828021353,\n          \"title\": \"Doodle NFT Bot Channel\",\n          \"type\": \"channel\"\n        },\n        \"chat\": {\n          \"id\": -1001828021353,\n          \"title\": \"Doodle NFT Bot Channel\",\n          \"type\": \"channel\"\n        },\n        \"date\": 1673428599,\n        \"text\": \"Hello\"\n      }\n    }\n  ]\n}\n```\n\n6. Add the chat id from the object above into your code and then let's test our bot.\n\n## Testing the bot\n\n1. Run your bot by having 2 terminals opened in the `backend` folder.\n\nIn the first one run\n\n```shell Shell\nngrok http 5001\n```\n\nIn the second one run\n\n```shell Shell\nnpm run start\n```\n\n2. Open up the Telegram channel we created and wait for notifications.\n\n![](/img/content/Screenshot_2023-01-11_at_10.53.51.webp)\n",
    "data": {
      "title": "Automated Blockchain Telegram Bot",
      "slug": "/guides/automated-blockchain-telegram-bot",
      "description": "This tutorial teaches you how to create an automated web3 telegram bot that listens to blockchain events and sends real-time notifications.",
      "tags": ["Streams", "Demos"]
    },
    "isEmpty": false,
    "excerpt": ""
  },
  {
    "content": "## Introduction\n\nThis tutorial teaches you how to create a web3 discord bot that listens to blockchain events and sends real-time notifications.\n\nWe will use discord.js, express and Moralis Streams API.\n\n### YouTube Tutorial\n\nhttps://www.youtube.com/watch?v=GiDXKT_AAIs\n\n\n## Project Setup\n\nThis section is split in multiple steps that you can follow. Let's dive in.\n\nYou can find the repository with the final code here: [Github](https://github.com/MoralisWeb3/youtube-tutorials/tree/main/Discord-Blockchain-Bot).\n\n1. ### Create a folder and initiate a project using the package manager of your choice.\n\n```bash npm2yarn\nnpm init -y\n```\n\nThis will initiate the project and create a `package.json` file containing the following:\n\n```json package.json\n{\n    \"name\": \"blockchainbot\",\n    \"version\": \"1.0.0\",\n    \"description\": \"\",\n    \"main\": \"index.js\",\n    \"scripts\": {\n        \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n    },\n    \"keywords\": [],\n    \"author\": \"\",\n    \"license\": \"MIT\"\n}\n\n```\n\n\n\n2. ### Install the required dependencies.\n\n```bash npm2yarn\nnpm install moralis express discord.js dotenv nodemon\n```\n\n3. ### Create an `index.js` file containing our express endpoint.\n\n```javascript index.js\nconst express = require(\"express\");\nconst app = express();\nconst port = 3000;\n\napp.use(express.json());\n\napp.post(\"/webhook\", async (req, res) => {\n  const { body, headers } = req;\n\n\tconsole.log(body);\n\n\tres.status(200).json();\n});\n\napp.listen(port, () => {\n\tconsole.log(`Listening to streams`);\n});\n\n```\n\n\n\n4. ### Setup an `ngrok` tunnel to our express app that will be running locally\n\n- Install `ngrok`.\n\n```shell Shell\nnpm i -g ngrok\n```\n\n\n\n- In a new terminal window run `ngrok http` to create a tunnel to our express app using the same port that we specified inside `index.js`\n\n```shell Shell\nngrok http 3000\n```\n\n\n\nThis will give us an address where out express app will be running and where we can setup webhooks for streams api.\n\n![](/img/content/c2b72e9-Screenshot_2022-11-24_at_15.24.44.webp)\n\n5. ### Start our express server.\n\nBack inside `package.json` add a start script that will start our express app and reload when we make changes.\n\n```json package.json\n{\n    \"name\": \"blockchainbot\",\n    \"version\": \"1.0.0\",\n    \"description\": \"\",\n    \"main\": \"index.js\",\n    \"scripts\": {\n        \"start\": \"nodemon index.js\",\n        \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n    },\n    \"author\": \"\",\n    \"license\": \"ISC\",\n    \"dependencies\": {\n        \"discord.js\": \"^14.6.0\",\n        \"dotenv\": \"^16.0.3\",\n        \"express\": \"^4.18.2\",\n        \"moralis\": \"^2.6.7\",\n        \"nodemon\": \"^2.0.20\"\n    }\n}\n\n```\n\n\n\nRun the start command.\n\n```bash npm2yarn\nnpm run start\n```\n\n## Streams Setup\n\nWe will use Moralis Streams API to get real-time events and send notifications\n\n Inside our admin panel access [streams section](https://admin.moralis.io/streams) and create a new stream.\n\n![](/img/content/1a3f153-Screenshot_2022-11-24_at_15.54.14.webp)\n\nSelect **Create From Scratch**\n\n![](/img/content/af70faf-Screenshot_2022-11-24_at_15.55.22.webp)\n\nFor this example we will use this simple donation contract, but you can use any smart contract of your choice:\n\n- Contract Address : `OxbD317B46A004CCF0e1773DBFcEE89E77e32D2dB9`\n- Abi: \n  ```json Abi\n  [{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Donate\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"newDonation\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}]\n  ```\n\nFor the webhook url have to use the url provided previously by ngrok, followed by our `/webhook` endpoint from our express app\n\n![](/img/content/3083fdd-Screenshot_2022-11-24_at_16.05.02.webp)\n\nOur contract is deployed on mumbai testnet, so here you will select the network that your smart contract is deployed on: \n\n![](/img/content/89031d2-Screenshot_2022-11-24_at_16.07.14.webp)\n\nBecause our donations are sending native currency to a smart contract, here we will select native transactions and check Event Emittance.\n\n![](/img/content/d2fc65d-Screenshot_2022-11-24_at_16.11.00.webp)\n\nNext we have to add the ABI and select the topic we want to stream.\n\n![](/img/content/7a495e0-image.webp)\n\nAfter creating the stream Moralis will send an empty POST request to confirm that the stream was created successfully.\n\n![](/img/content/3ce0485-image.webp)\n\n## Verify Stream Sender\n\nRight now everybody who knows our webhook endpoint is able to make a POST request to our express server.\n\nTo stop this from causing any errors, what we have to do now is to verify that the requests are sent by Moralis using `Moralis.Streams.verifySignature`.\n\nBack to our express endpoint, we can add logic that allows only request coming from Moralis to go through.\n\n1. ### Go to [Moralis Admin Panel](https://admin.moralis.io/web3apis) and copy your web3 api key.\n\n![](/img/content/a254a4d-Screenshot_2022-11-24_at_16.29.26.webp)\n\n2. ### Create an `.env` file.\n\n```shell .env\nAPIKEY = 'YOUR_API_KEY'\n```\n\n\n\n3. ### Verify the request.\n\n```javascript index.js\nconst express = require(\"express\");\nconst Moralis = require(\"moralis\").default;\nrequire(\"dotenv\").config();\nconst app = express();\nconst port = 3000;\n\napp.use(express.json());\n\napp.post(\"/webhook\", async (req, res) => {\n  const { body, headers } = req;\n\n  try {\n    Moralis.Streams.verifySignature({\n      body,\n      signature: headers[\"x-signature\"],\n    });\n    \n    return res.status(200).json();\n  } catch (e) {\n    console.log(\"Not Moralis\");\n    return res.status(400).json();\n  }\n});\n\nMoralis.start({\n  apiKey: process.env.APIKEY,\n}).then(() => {\n  app.listen(port, () => {\n    console.log(`Listening to streams`);\n  });\n});\n```\n\n\n\n## Discord Bot Setup\n\nWe will now begin to setup our bot to send notifications to our discord server.\n\n1. Access [Discord Developer Portal](https://discord.com/developers) and create a new application.\n\n![](/img/content/a10c89c-Screenshot_2022-11-24_at_16.41.34.webp)\n\n2. Add a new bot to your application.\n\n![](/img/content/f180c62-Screenshot_2022-11-24_at_16.44.35.webp)\n\n3. Add the scope and the permissions to your bot.\n\n![](/img/content/77f8469-image.webp)\n\n![](/img/content/590011d-image.webp)\n\n3. Open the generated url in a new browser tab and invite the bot to your server.\n\n![](/img/content/385ae12-image.webp)\n\n5. Back in the Bot section, Reset and copy the new token.\n\n![](/img/content/47b8e98-Screenshot_2022-11-24_at_16.51.35.webp)\n\n6. Add the token and the channel id you wish to send the message to inside your `.env` file.\n\n```shell .env\nAPIKEY = 'YOUR_API_KEY'\nPASS = 'YOUR_BOT_TOKEN'\nCHANNEL = 'CHANNEL_ID'\n```\n\n\n\n7. Add the discord client to your `index.js` and setup the login to send messages.\n\n```javascript index.js\nconst express = require(\"express\");\nconst Moralis = require(\"moralis\").default;\nconst discord = require(\"discord.js\");\nrequire(\"dotenv\").config();\nconst app = express();\nconst port = 3000;\n\nconst client = new discord.Client({\n    intents: [],\n});\n\nclient.login(process.env.PASS);\n\napp.use(express.json());\n\napp.post(\"/webhook\", async (req, res) => {\n  const { body, headers } = req;\n\n  try {\n    Moralis.Streams.verifySignature({\n      body,\n      signature: headers[\"x-signature\"],\n    });\n\n\n    let from = body.txs[0].fromAddress;\n    let amount = Number(body.txs[0].value / 1E18);\n\n    const channel = await client.channels.fetch(process.env.CHANNEL);\n    channel.send(`New Donation submitted by ${from}, for ${amount.toFixed(2)} MATIC!!!!`);\n\n    return res.status(200).json();\n  } catch (e) {\n    console.log(\"Not Moralis\");\n    return res.status(400).json();\n  }\n});\n\nMoralis.start({\n  apiKey: process.env.APIKEY,\n}).then(() => {\n  app.listen(port, () => {\n    console.log(`Listening to streams`);\n  });\n});\n```\n\n\n\n## Testing the bot\n\n1. Run your bot.\n\n```shell Shell\nnode index.js\n```\n\n\n\n2. To test our bot, We can now call the donation function from our contract.\n\n![](/img/content/604fd4b-image.webp)\n\n\n\n3. We should see a new notification sent by our bot.\n\n![](/img/content/e8aac1e-image.webp)\n",
    "data": {
      "title": "Blockchain Discord Bot",
      "slug": "/guides/blockchain-discord-bot",
      "description": "This tutorial teaches you how to create a web3 discord bot that listens to blockchain events and sends real-time notifications.",
      "tags": ["Streams", "Demos"]
    },
    "isEmpty": false,
    "excerpt": ""
  },
  {
    "content": "\n## Introduction\n\nThis tutorial teaches you how to use the Streams API to display live desktop notifications for any [USDT](https://etherscan.io/token/0xdac17f958d2ee523a2206206994597c13d831ec7) transfers.\n\nYou can find the repository with the [final code here](https://github.com/MoralisWeb3/youtube-tutorials/tree/main/DesktopNotifications).\n\n## YouTube Tutorial\n\nhttps://www.youtube.com/watch?v=QtstmvVeI18\n\n## How to Get Started\n\n1. Create an Express.js API\n2. Create a stream using the [Streams API](/streams-api/evm)\n3. Integrate your app with Moralis services\n\n## Initial Setup\n\n1. Create a new folder and set up a new project:\n\n```shell\nnpm init -y\n```\n\n2. Install the required dependencies:\n\n- `express` - our API to receive the webhooks\n- `nodemon` - for restarting the app automatically when we make code changes\n- `node-notifier` - for displaying the notifications\n\n```shell\nnpm install express nodemon node-notifier\n```\n\n## Setting Up Express.js\n\nWe will set up a basic Express.js server.\n\n1. Create an `index.js` file and add:\n\n```javascript\nconst express = require(\"express\");\nconst app = express();\nconst port = 3000;\n\napp.use(express.json());\n\napp.listen(port, () => {\n  console.log(`Listening to streams`);\n});\n```\n\n2. In the same file, we will set up a basic API endpoint called `/webhook`:\n\n```javascript\napp.post(\"/webhook\", (req, res) => {\n  const webhook = req.body;\n\n  console.log(webhook);\n\n  return res.status(200).json();\n});\n```\n\n3. Open `package.json` and add this script under `scripts` to allow us to use `npm run start` to run the app:\n\n```json\n\"scripts\": {\n  \"start\": \"nodemon index.js\",\n  ...\n},\n```\n\n4. Run your Express server:\n\n```shell\nnpm run start\n```\n\n## Setting Up Ngrok\n\nWe will need to expose this server so it can be reached from outside our local network. We can use [ngrok](https://ngrok.com/).\n\n1. Follow the [ngrok setup instructions here](https://ngrok.com/download).\n2. Run `ngrok` on port 3000:\n\n```shell\nngrok http 3000\n```\n\nIf successful, you should see output similar to the following where an Ngrok URL is mapped to your local server:\n\n```text\nForwarding https://***.ngrok.io -> http://localhost:3000\n```\n\nThis `ngrok.io` URL is what you will use when setting up the stream to receive the webhooks.\n\n## Setting Up A Stream\n\nNow we will set up a stream to send webhooks to our server every time a USDT amount over 50k is transferred. You can [follow this guide](/streams-api/evm/using-webui) to get started.\n\n1. Create a new stream and select \"Create From Scratch\".\n2. Use these options for your stream:\n\n- **address** =`0xdAC17F958D2ee523a2206206994597C13D831ec7`\n- **description** = `USDT transfers over 50K`\n- **webhook URL** = [`https://***.ngrok.io/webhook`](https://***.ngrok.io/webhook)\n- **tag** = `USDT50`\n- **network** = `Ethereum Mainnet`\n\n![](/img/content/5b7b050-Notifications_1.webp)\n\n3. Tick \"Contract interactions (logs)\" and \"Event Emittance\", and add the [USDT contract](https://etherscan.io/token/0xdac17f958d2ee523a2206206994597c13d831ec7#code)'s ABI:\n\n```json\n[\n  {\n    \"constant\": true,\n    \"inputs\": [],\n    \"name\": \"name\",\n    \"outputs\": [{ \"name\": \"\", \"type\": \"string\" }],\n    \"payable\": false,\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": false,\n    \"inputs\": [{ \"name\": \"_upgradedAddress\", \"type\": \"address\" }],\n    \"name\": \"deprecate\",\n    \"outputs\": [],\n    \"payable\": false,\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": false,\n    \"inputs\": [\n      { \"name\": \"_spender\", \"type\": \"address\" },\n      { \"name\": \"_value\", \"type\": \"uint256\" }\n    ],\n    \"name\": \"approve\",\n    \"outputs\": [],\n    \"payable\": false,\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": true,\n    \"inputs\": [],\n    \"name\": \"deprecated\",\n    \"outputs\": [{ \"name\": \"\", \"type\": \"bool\" }],\n    \"payable\": false,\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": false,\n    \"inputs\": [{ \"name\": \"_evilUser\", \"type\": \"address\" }],\n    \"name\": \"addBlackList\",\n    \"outputs\": [],\n    \"payable\": false,\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": true,\n    \"inputs\": [],\n    \"name\": \"totalSupply\",\n    \"outputs\": [{ \"name\": \"\", \"type\": \"uint256\" }],\n    \"payable\": false,\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": false,\n    \"inputs\": [\n      { \"name\": \"_from\", \"type\": \"address\" },\n      { \"name\": \"_to\", \"type\": \"address\" },\n      { \"name\": \"_value\", \"type\": \"uint256\" }\n    ],\n    \"name\": \"transferFrom\",\n    \"outputs\": [],\n    \"payable\": false,\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": true,\n    \"inputs\": [],\n    \"name\": \"upgradedAddress\",\n    \"outputs\": [{ \"name\": \"\", \"type\": \"address\" }],\n    \"payable\": false,\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": true,\n    \"inputs\": [{ \"name\": \"\", \"type\": \"address\" }],\n    \"name\": \"balances\",\n    \"outputs\": [{ \"name\": \"\", \"type\": \"uint256\" }],\n    \"payable\": false,\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": true,\n    \"inputs\": [],\n    \"name\": \"decimals\",\n    \"outputs\": [{ \"name\": \"\", \"type\": \"uint256\" }],\n    \"payable\": false,\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": true,\n    \"inputs\": [],\n    \"name\": \"maximumFee\",\n    \"outputs\": [{ \"name\": \"\", \"type\": \"uint256\" }],\n    \"payable\": false,\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": true,\n    \"inputs\": [],\n    \"name\": \"_totalSupply\",\n    \"outputs\": [{ \"name\": \"\", \"type\": \"uint256\" }],\n    \"payable\": false,\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": false,\n    \"inputs\": [],\n    \"name\": \"unpause\",\n    \"outputs\": [],\n    \"payable\": false,\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": true,\n    \"inputs\": [{ \"name\": \"_maker\", \"type\": \"address\" }],\n    \"name\": \"getBlackListStatus\",\n    \"outputs\": [{ \"name\": \"\", \"type\": \"bool\" }],\n    \"payable\": false,\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": true,\n    \"inputs\": [\n      { \"name\": \"\", \"type\": \"address\" },\n      { \"name\": \"\", \"type\": \"address\" }\n    ],\n    \"name\": \"allowed\",\n    \"outputs\": [{ \"name\": \"\", \"type\": \"uint256\" }],\n    \"payable\": false,\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": true,\n    \"inputs\": [],\n    \"name\": \"paused\",\n    \"outputs\": [{ \"name\": \"\", \"type\": \"bool\" }],\n    \"payable\": false,\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": true,\n    \"inputs\": [{ \"name\": \"who\", \"type\": \"address\" }],\n    \"name\": \"balanceOf\",\n    \"outputs\": [{ \"name\": \"\", \"type\": \"uint256\" }],\n    \"payable\": false,\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": false,\n    \"inputs\": [],\n    \"name\": \"pause\",\n    \"outputs\": [],\n    \"payable\": false,\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": true,\n    \"inputs\": [],\n    \"name\": \"getOwner\",\n    \"outputs\": [{ \"name\": \"\", \"type\": \"address\" }],\n    \"payable\": false,\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": true,\n    \"inputs\": [],\n    \"name\": \"owner\",\n    \"outputs\": [{ \"name\": \"\", \"type\": \"address\" }],\n    \"payable\": false,\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": true,\n    \"inputs\": [],\n    \"name\": \"symbol\",\n    \"outputs\": [{ \"name\": \"\", \"type\": \"string\" }],\n    \"payable\": false,\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": false,\n    \"inputs\": [\n      { \"name\": \"_to\", \"type\": \"address\" },\n      { \"name\": \"_value\", \"type\": \"uint256\" }\n    ],\n    \"name\": \"transfer\",\n    \"outputs\": [],\n    \"payable\": false,\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": false,\n    \"inputs\": [\n      { \"name\": \"newBasisPoints\", \"type\": \"uint256\" },\n      { \"name\": \"newMaxFee\", \"type\": \"uint256\" }\n    ],\n    \"name\": \"setParams\",\n    \"outputs\": [],\n    \"payable\": false,\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": false,\n    \"inputs\": [{ \"name\": \"amount\", \"type\": \"uint256\" }],\n    \"name\": \"issue\",\n    \"outputs\": [],\n    \"payable\": false,\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": false,\n    \"inputs\": [{ \"name\": \"amount\", \"type\": \"uint256\" }],\n    \"name\": \"redeem\",\n    \"outputs\": [],\n    \"payable\": false,\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": true,\n    \"inputs\": [\n      { \"name\": \"_owner\", \"type\": \"address\" },\n      { \"name\": \"_spender\", \"type\": \"address\" }\n    ],\n    \"name\": \"allowance\",\n    \"outputs\": [{ \"name\": \"remaining\", \"type\": \"uint256\" }],\n    \"payable\": false,\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": true,\n    \"inputs\": [],\n    \"name\": \"basisPointsRate\",\n    \"outputs\": [{ \"name\": \"\", \"type\": \"uint256\" }],\n    \"payable\": false,\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": true,\n    \"inputs\": [{ \"name\": \"\", \"type\": \"address\" }],\n    \"name\": \"isBlackListed\",\n    \"outputs\": [{ \"name\": \"\", \"type\": \"bool\" }],\n    \"payable\": false,\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": false,\n    \"inputs\": [{ \"name\": \"_clearedUser\", \"type\": \"address\" }],\n    \"name\": \"removeBlackList\",\n    \"outputs\": [],\n    \"payable\": false,\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": true,\n    \"inputs\": [],\n    \"name\": \"MAX_UINT\",\n    \"outputs\": [{ \"name\": \"\", \"type\": \"uint256\" }],\n    \"payable\": false,\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": false,\n    \"inputs\": [{ \"name\": \"newOwner\", \"type\": \"address\" }],\n    \"name\": \"transferOwnership\",\n    \"outputs\": [],\n    \"payable\": false,\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": false,\n    \"inputs\": [{ \"name\": \"_blackListedUser\", \"type\": \"address\" }],\n    \"name\": \"destroyBlackFunds\",\n    \"outputs\": [],\n    \"payable\": false,\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      { \"name\": \"_initialSupply\", \"type\": \"uint256\" },\n      { \"name\": \"_name\", \"type\": \"string\" },\n      { \"name\": \"_symbol\", \"type\": \"string\" },\n      { \"name\": \"_decimals\", \"type\": \"uint256\" }\n    ],\n    \"payable\": false,\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"constructor\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [{ \"indexed\": false, \"name\": \"amount\", \"type\": \"uint256\" }],\n    \"name\": \"Issue\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [{ \"indexed\": false, \"name\": \"amount\", \"type\": \"uint256\" }],\n    \"name\": \"Redeem\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [{ \"indexed\": false, \"name\": \"newAddress\", \"type\": \"address\" }],\n    \"name\": \"Deprecate\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      { \"indexed\": false, \"name\": \"feeBasisPoints\", \"type\": \"uint256\" },\n      { \"indexed\": false, \"name\": \"maxFee\", \"type\": \"uint256\" }\n    ],\n    \"name\": \"Params\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      { \"indexed\": false, \"name\": \"_blackListedUser\", \"type\": \"address\" },\n      { \"indexed\": false, \"name\": \"_balance\", \"type\": \"uint256\" }\n    ],\n    \"name\": \"DestroyedBlackFunds\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [{ \"indexed\": false, \"name\": \"_user\", \"type\": \"address\" }],\n    \"name\": \"AddedBlackList\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [{ \"indexed\": false, \"name\": \"_user\", \"type\": \"address\" }],\n    \"name\": \"RemovedBlackList\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      { \"indexed\": true, \"name\": \"owner\", \"type\": \"address\" },\n      { \"indexed\": true, \"name\": \"spender\", \"type\": \"address\" },\n      { \"indexed\": false, \"name\": \"value\", \"type\": \"uint256\" }\n    ],\n    \"name\": \"Approval\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      { \"indexed\": true, \"name\": \"from\", \"type\": \"address\" },\n      { \"indexed\": true, \"name\": \"to\", \"type\": \"address\" },\n      { \"indexed\": false, \"name\": \"value\", \"type\": \"uint256\" }\n    ],\n    \"name\": \"Transfer\",\n    \"type\": \"event\"\n  },\n  { \"anonymous\": false, \"inputs\": [], \"name\": \"Pause\", \"type\": \"event\" },\n  { \"anonymous\": false, \"inputs\": [], \"name\": \"Unpause\", \"type\": \"event\" }\n]\n```\n\n4. For \"Topic 0\", tick \"Transfer\":\n\n![](/img/content/084c74d-Notifications_2.webp)\n\n5. Under \"Advanced Options\", add:\n\n```json\n[\n  {\n    \"topic0\": \"Transfer(address,address,uint256)\",\n    \"filter\": { \"gt\": [\"value\", 50000000000] }\n  }\n]\n```\n\n6. Finally, click \"Create Stream\".\n\n![](/img/content/eaa0626-Notifications_3.webp)\n\nYou should be redirected to [`https://admin.moralis.io/streams`](https://admin.moralis.io/streams). If not, check your server's terminal, you should start seeing some webhook data:\n\n![](/img/content/bf1b009-Notifications_4.webp)\n\nIf you don't seem to be getting any webhooks, you can reduce the filter amount.\n\n## Setting Up Notifications\n\nNow that we are receiving webhooks, we will set up the notifications.\n\n1. In `index.js`, add the `node-notifier` import:\n\n```javascript\nconst notifier = require(\"node-notifier\");\n```\n\n2. Inside our `/webhook` endpoint handler, add:\n\n```javascript\nfor (const erc20Transfer of webhook.erc20Transfers) {\n  const addrs = `${erc20Transfer.from.slice(0, 4)}...${erc20Transfer.from.slice(\n    38\n  )}`;\n  const amount = Number(erc20Transfer.valueWithDecimals).toFixed(0);\n\n  notifier.notify({\n    title: \"NEW USDT Transfer\",\n    message: `${addrs} just sent \\n$${amount}`,\n  });\n}\n```\n\nYour final `index.js` should look like this:\n\n```javascript\nconst express = require(\"express\");\nconst notifier = require(\"node-notifier\");\nconst app = express();\nconst port = 3000;\n\napp.use(express.json());\n\napp.post(\"/webhook\", (req, res) => {\n  const webhook = req.body;\n\n  for (const erc20Transfer of webhook.erc20Transfers) {\n    const addrs = `${erc20Transfer.from.slice(\n      0,\n      4\n    )}...${erc20Transfer.from.slice(38)}`;\n    const amount = Number(erc20Transfer.valueWithDecimals).toFixed(0);\n\n    notifier.notify({\n      title: \"NEW USDT Transfer\",\n      message: `${addrs} just sent \\n$${amount}`,\n    });\n  }\n\n  return res.status(200).json();\n});\n\napp.listen(port, () => {\n  console.log(`Listening to streams`);\n});\n```\n\nYou should start receiving desktop notifications.\n",
    "data": {
      "title": "Live Crypto Notifications",
      "slug": "/guides/live-crypto-notifications",
      "description": "This tutorial teaches you how to use the Streams API to display live desktop notifications for any USDT transfers.",
      "tags": ["Streams", "Demos"]
    },
    "isEmpty": false,
    "excerpt": ""
  },
  {
    "content": "\n## What is an NFT API?\n\n![](/img/content/0d1bb91-image.webp)\n\nAn [NFT API](https://moralis.io/api/nft/) is a collection of APIs that can be used to index NFT data, e.g. NFT balance, NFT metadata, from multiple [EVM chains](/web3-data-api/evm#supported-chains) that we support.\n\nThe [NFT API](https://moralis.io/api/nft/) is designed to provide high-quality, structured NFT data to developers to build application that interact with various kinds of NFTs (ERC721, ERC115, others).\n\nTherefore, the ideal use cases for the [NFT API](https://moralis.io/api/nft/) are listed as below, but not limited to:\n\n- Portfolio dashboard\n- Wallets\n- NFT-gating applications (NFT-based tickets or memberships)\n- NFT marketplaces\n- etc.\n\nThe [NFT API](https://moralis.io/api/nft/) is divided into **6 categories** based on their use cases as follows:\n\n### Get NFTs API\n\nThe [Get NFTs API](/web3-data-api/evm/reference/get-multiple-nfts) is a collection of [NFT API](https://moralis.io/api/nft/) that provides developer with all NFT stats (name, address, metadata, etc.) that fulfills certain search requirements, e.g. NFTs owned by a wallet, NFTs in a collection, NFTs with specific metadata, etc.\n\nThis API category comprised of 4 APIs:\n\n| API Name                                                          | Path                 | Use Cases                                                                                                                  |\n| ----------------------------------------------------------------- | -------------------- | -------------------------------------------------------------------------------------------------------------------------- |\n| [getMultipleNFTs](/web3-data-api/evm/reference/get-multiple-nfts) | /nft/getMultipleNFTs | Fetch a complete stats of multiple NFTs (max 25 per call) in a given `tokens` array.                                       |\n| [getWalletNFTs](/web3-data-api/evm/reference/get-wallet-nfts)     | /{address}/nft       | Fetch all NFTs in a given wallet `address`. This is ideal for displaying NFT balance for a portfolio dashboard.            |\n| [getContractNFTs](/web3-data-api/evm/reference/get-contract-nfts) | /nft/{address}       | Fetch all tokens in a given NFT collection `address`.                                                                      |\n| [searchNFTs](/web3-data-api/evm/reference/search-nfts)            | /nft/search          | Fetch all NFT that have metadata that contains a given `q` string. This is ideal for building an NFT search functionality. |\n\n### Get NFT Transfers API\n\nThe [Get NFT Transfers](/web3-data-api/evm/reference/get-wallet-nft-transfers) API is a collection of [NFT API](https://moralis.io/api/nft/) that provides developer with various historical NFT transfers data.\n\nThis API category comprised of 5 APIs:\n\n| API Name                                                                                   | Path                                        | Use Cases                                                                                                                                                                |\n| ------------------------------------------------------------------------------------------ | ------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| [getWalletNFTTransfers](/web3-data-api/evm/reference/get-wallet-nft-transfers)             | /{address}/nft/transfers                    | Fetch all transfers of NFT that interacted with a given `address`. This does not include any indirect NFT transfers, e.g. transfering NFT with OpenSea contract.         |\n| [getNFTContractTransfers](/web3-data-api/evm/reference/get-nft-contract-transfers)         | /nft/{address}/transfers                    | Fetch all transfers of a specific NFT collection with a given contract `address`.                                                                                        |\n| [getNFTTransfersFromToBlock](/web3-data-api/evm/reference/get-nft-transfers-from-to-block) | /nft/transfers                              | Fetch all transfers of NFTs within the given `from_block` and `to_block` range. This is ideal for fetching NFT transfers from a specific range of time or block numbers. |\n| [getNFTTransfersByBlock](/web3-data-api/evm/reference/get-nft-transfers-by-block)          | /block/{block_number_or_hash}/nft/transfers | Fetch all transfers of NFTs in a given `block_number_or_hash`                                                                                                            |\n| [getNFTTransfers](/web3-data-api/evm/reference/get-nft-transfers)                          | /nft/{address}/{token_id}/transfers         | Fetch all transfers of a specific NFT with given `address` and `token_id`.                                                                                               |\n\n### Get NFT Collections API\n\nThe [Get NFT Collections](/web3-data-api/evm/reference/get-wallet-nft-collections) API is a collection of [NFT API](https://moralis.io/api/nft/) that provides developer with NFT collections-related data.\n\nIf an NFT collection has not been synced by the [Moralis NFT API](https://moralis.io/api/nft/), it is also possible to manually index it by calling the [syncNFTContract](/web3-data-api/evm/reference/sync-nft-contract) API.\n\nThis API category comprised of 3 APIs:\n\n| API Name                                                                           | Path                       | Use Cases                                                                                                          |\n| ---------------------------------------------------------------------------------- | -------------------------- | ------------------------------------------------------------------------------------------------------------------ |\n| [getWalletNFTCollections](/web3-data-api/evm/reference/get-wallet-nft-collections) | /{address}/nft/collections | Fetch all NFT collection (not specific token) that is owned by a given `address`.                                  |\n| [getNFTContractMetadata](/web3-data-api/evm/reference/get-nft-contract-metadata)   | /nft/{address}/metadata    | Fetch the NFT collection metadata (name, symbol, and contract type _ERC721, ERC115, others_) of a given `address`. |\n| [syncNFTContract](/web3-data-api/evm/reference/sync-nft-contract)                  | /nft/{address}/sync        | Manually sync to index an unindexed NFT collection with a given `address`.                                         |\n\n### Get NFT Owners API\n\nThe [Get NFT Owners](/web3-data-api/evm/reference/get-nft-owners) API is a collection of [NFT API](https://moralis.io/api/nft/) that provides developer with fetching and verifying ownership of certain NFT or NFT collections.\n\nThis API category comprised of 2 APIs:\n\n| API Name                                                                    | Path                             | Use Cases                                                                                                                                                                     |\n| --------------------------------------------------------------------------- | -------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| [getNFTOwners](/web3-data-api/evm/reference/get-nft-owners)                 | /nft/{address}/owners            | Fetch all the token holders/owners of a given NFT collection with contract `address`. This can be used to verify NFT ownership for NFT-gating application.                    |\n| [getNFTTokenIdOwners](/web3-data-api/evm/reference/get-nft-token-id-owners) | /nft/{address}/{token_id}/owners | Fetch all the token holders/owners of a given specific NFT token with contract `address` and `token_id`. This can be used to verify NFT ownership for NFT-gating application. |\n\n### Get NFT Market Data API\n\nThe [Get NFT Market Data](/web3-data-api/evm/reference/get-nft-trades) API is a collection of [NFT API](https://moralis.io/api/nft/) that provides developer with all NFT market related-data, such as NFT historical trades and price.\n\nThis API category comprised of 2 APIs:\n\n| API Name                                                               | Path                       | Use Cases                                                                                      |\n| ---------------------------------------------------------------------- | -------------------------- | ---------------------------------------------------------------------------------------------- |\n| [getNFTTrades](/web3-data-api/evm/reference/get-nft-trades)            | /nft/{address}/trades      | Fetch the list of trades of an NFT with a given contract `address` on OpenSea NFT Marketplace. |\n| [getNFTLowestPrice](/web3-data-api/evm/reference/get-nft-lowest-price) | /nft/{address}/lowestprice | Fetch the lowest price of an NFT with a given contract `address` on OpenSea NFT Marketplace.   |\n\n### Get NFT Metadata API\n\nThe [Get NFT Metadata](/web3-data-api/evm/reference/get-nft-metadata) API is a collection of [NFT API](https://moralis.io/api/nft/) that provides developer with metadata of NFTs that would like to be indexed. This works out of the box with various types of NFTs (ERC721, ERC1155, others) and either on-chain or off-chain metadata.\n\nThis API comprised of 2 APIs:\n\n| API Name                                                        | Path                                     | Use Cases                                                                                               |\n| --------------------------------------------------------------- | ---------------------------------------- | ------------------------------------------------------------------------------------------------------- |\n| [getNFTMetadata](/web3-data-api/evm/reference/get-nft-metadata) | /nft/{address}/{token_id}                | Fetch the metadata (either off-chain or on-chain) a specific NFT with a given `address` and `token_id`. |\n| [reSyncMetadata](/web3-data-api/evm/reference/resync-metadata)  | nft/{address}/{token_id}/metadata/resync | Resync/Update NFT metadata to its latest, if it dynamically changes.                                    |\n\n## How to get started?\n\nTo get started with [Moralis NFT API](https://moralis.io/api/nft/), there are two methods that can be used, depending on the programming language that you are using:\n\n| Programming Languages                 | Method       |\n| ------------------------------------- | ------------ |\n| JavaScript/TypeScript, Python         | Moralis SDKs |\n| Others (e.g. Java, C/C++, Ruby, etc.) | REST API     |\n\nFor this guide, we'll particularly use the Moralis SDK for examples.\n\nIf you would like to use other languages calling the Moralis NFT API using regular REST API call, then make sure to check the [NFT API reference pages](/web3-data-api/evm/reference/get-multiple-nfts) to get all the parameters and responses type.\n\n### Step 1: Install the Moralis SDK\n\nimport SetupMoralis from '/docs/partials/\\_install-moralis-sdk.mdx';\n\n<SetupMoralis node=\"moralis\" python=\"moralis\" />\n\n### Step 2: Add to Your Code\n\nTo use the NFT API, it is very simple. All the [NFT API](https://moralis.io/api/nft/) can be called by using `Moralis.EvmApi.nft.{apiName}` where `apiName` will be replaced by the [NFT API](https://moralis.io/api/nft/) used.\n\nIn this guide, suppose you are building a simple NFT portfolio dashboard.\n\nLet's start to use the [NFT API](https://moralis.io/api/nft/) to build these three initial features:\n\n#### Feature #1: Fetch NFT balance of the user's wallet address\n\nIn order to fetch the NFT balance of the user's wallet address, Moralis provides you with a [getWalletNFTs](/web3-data-api/evm/reference/get-wallet-nfts) endpoint to do so.\n\nHere you'll need two parameters: `address` and `chain`.\n\nOnce you've obtained both the `address` and `chain`, you can copy the following code and add it to your existing codebase:\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n<Tabs groupId=\"programming-language\">\n  <TabItem value=\"javascript\" label=\"JavaScript\" default>\n\n```javascript index.js\nconst Moralis = require(\"moralis\").default;\nconst { EvmChain } = require(\"@moralisweb3/common-evm-utils\");\n\nconst runApp = async () => {\n  await Moralis.start({\n    apiKey: \"YOUR_API_KEY\",\n    // ...and any other configuration\n  });\n\n  const address = \"USER_WALLET_ADDRESS\";\n\n  const chain = \"CHAIN\" // e.g EvmChain.ETHEREUM, EvmChain.POLYGON\n\n  const response = await Moralis.EvmApi.nft.getWalletNFTs({\n    address,\n    chain,\n  });\n\n  console.log(response.raw);\n};\n\nrunApp();\n```\n\n</TabItem>\n<TabItem value=\"typescript\" label=\"TypeScript\">\n\n```typescript index.ts\nimport Moralis from \"moralis\";\nimport { EvmChain } from \"@moralisweb3/common-evm-utils\";\n\nconst runApp = async () => {\n  await Moralis.start({\n    apiKey: \"YOUR_API_KEY\",\n    // ...and any other configuration\n  });\n\n  const address = \"USER_WALLET_ADDRESS\";\n\n  const chain = \"CHAIN\" // e.g EvmChain.ETHEREUM, EvmChain.POLYGON\n\n  const response = await Moralis.EvmApi.nft.getWalletNFTs({\n    address,\n    chain,\n  });\n\n  console.log(response.raw);\n};\n\nrunApp();\n```\n\n</TabItem>\n<TabItem value=\"python\" label=\"Python\">\n\n```python index.py\nfrom moralis import evm_api\nimport json\n\napi_key = \"YOUR_API_KEY\"\nparams = {\n    \"address\": \"USER_WALLET_ADDRESS\",\n    \"chain\": \"CHAIN\", # e.g. \"eth\", \"polygon\", etc.\n}\n\nresult = evm_api.nft.get_wallet_nfts(\n    api_key=api_key,\n    params=params,\n)\n\n# converting it to json because of unicode characters\nprint(json.dumps(result, indent=4))\n```\n\n</TabItem>\n</Tabs>\n\nOnce the code is added, you will be able to obtain all the NFT that the user own in its wallet address using just a few lines of code with [Moralis NFT API](https://moralis.io/api/nft/).\n\n#### Feature #2: Fetch Historical NFT transfers that interacted with user's wallet address\n\nIn order to fetch the historical NFT transfers that interacted the user's wallet address, Moralis provides you with a [getWalletNFTTransfers](/web3-data-api/evm/reference/get-wallet-nft-transfers) endpoint to do so.\n\nHere you'll need two parameters: `address` and `chain`.\n\nOnce you've obtained both the `address` and `chain`, you can copy the following code and add it to your existing codebase:\n\n<Tabs groupId=\"programming-language\">\n  <TabItem value=\"javascript\" label=\"JavaScript\" default>\n\n```javascript index.js\nconst Moralis = require(\"moralis\").default;\nconst { EvmChain } = require(\"@moralisweb3/common-evm-utils\");\n\nconst runApp = async () => {\n  await Moralis.start({\n    apiKey: \"YOUR_API_KEY\",\n    // ...and any other configuration\n  });\n\n  const address = \"USER_WALLET_ADDRESS\";\n\n  const chain = \"CHAIN\" // e.g EvmChain.ETHEREUM, EvmChain.POLYGON\n\n  const response = await Moralis.EvmApi.nft.getWalletNFTTransfers({\n    address,\n    chain,\n  });\n\n  console.log(response.raw);\n};\n\nrunApp();\n```\n\n</TabItem>\n<TabItem value=\"typescript\" label=\"TypeScript\">\n\n```typescript index.ts\nimport Moralis from \"moralis\";\nimport { EvmChain } from \"@moralisweb3/common-evm-utils\";\n\nconst runApp = async () => {\n  await Moralis.start({\n    apiKey: \"YOUR_API_KEY\",\n    // ...and any other configuration\n  });\n\n  const address = \"USER_WALLET_ADDRESS\";\n\n  const chain = \"CHAIN\" // e.g EvmChain.ETHEREUM, EvmChain.POLYGON\n\n  const response = await Moralis.EvmApi.nft.getWalletNFTTransfers({\n    address,\n    chain,\n  });\n\n  console.log(response.raw);\n};\n\nrunApp();\n```\n\n</TabItem>\n<TabItem value=\"python\" label=\"Python\">\n\n```python index.py\nfrom moralis import evm_api\n\napi_key = \"YOUR_API_KEY\"\n\nparams = {\n    \"address\": \"USER_WALLET_ADDRESS\",\n    \"chain\": \"CHAIN\", # e.g. \"eth\", \"polygon\", etc.\n}\n\nresult = evm_api.nft.get_wallet_nft_transfers(\n  api_key=api_key,\n  params=params,\n)\n\nprint(result)\n```\n\n</TabItem>\n</Tabs>\n\nOnce the code is added, you will be able to obtain the historical NFT transfers that interacted the user's wallet address using just a few lines of code with [Moralis NFT API](https://moralis.io/api/nft/).\n\n#### Feature #3: Fetch NFT lowest price from the NFT balance\n\nIn order to fetch the NFT price from the NFT balance, Moralis provides you with a [getNFTLowestPrice](/web3-data-api/evm/reference/get-nft-lowest-price) endpoint to do so.\n\nHere you'll need two parameters: `address` and `chain`.\n\nOnce you've obtained both the `address` and `chain`, you can copy the following code and add it to your existing codebase:\n\n<Tabs groupId=\"programming-language\">\n  <TabItem value=\"javascript\" label=\"JavaScript\" default>\n\n```javascript index.js\nconst Moralis = require(\"moralis\").default;\nconst { EvmChain } = require(\"@moralisweb3/common-evm-utils\");\n\nconst runApp = async () => {\n  await Moralis.start({\n    apiKey: \"YOUR_API_KEY\",\n    // ...and any other configuration\n  });\n\n  const address = \"NFT_CONTRACT_ADDRESS\"; // provided from `getWalletNFTs`\n\n  const chain = \"CHAIN\" // e.g EvmChain.ETHEREUM, EvmChain.POLYGON\n\n  const response = await Moralis.EvmApi.nft.getNFTLowestPrice({\n    address,\n    chain,\n  });\n\n  console.log(response.raw);\n};\n\nrunApp();\n```\n\n</TabItem>\n<TabItem value=\"typescript\" label=\"TypeScript\">\n\n```typescript index.ts\nimport Moralis from \"moralis\";\nimport { EvmChain } from \"@moralisweb3/common-evm-utils\";\n\nconst runApp = async () => {\n  await Moralis.start({\n    apiKey: \"YOUR_API_KEY\",\n    // ...and any other configuration\n  });\n\n  const address = \"NFT_CONTRACT_ADDRESS\"; // provided from `getWalletNFTs`\n\n  const chain = \"CHAIN\" // e.g EvmChain.ETHEREUM, EvmChain.POLYGON\n\n  const response = await Moralis.EvmApi.nft.getNFTLowestPrice({\n    address,\n    chain,\n  });\n\n  console.log(response.raw);\n};\n\nrunApp();\n```\n\n</TabItem>\n<TabItem value=\"python\" label=\"Python\">\n\n```python index.py\nfrom moralis import evm_api\n\napi_key = \"YOUR_API_KEY\"\n\nparams = {\n    \"address\": \"NFT_CONTRACT_ADDRESS\", # provided from `getWalletNFTs`\n    \"chain\": \"CHAIN\", # e.g. \"eth\", \"polygon\", etc.\n}\n\nresult = evm_api.nft.get_nft_lowest_price(\n  api_key=api_key,\n  params=params,\n)\n\nprint(result)\n```\n\n</TabItem>\n</Tabs>\n\nOnce the code is added, you will be able to obtain the NFTs lowest price from the NFT balance using just a few lines of code with [Moralis NFT API](https://moralis.io/api/nft/).\n\n### Step 3: Going Live!\n\nOnce you have a few lines of new code, you have successfully integrated the [Moralis NFT API](https://moralis.io/api/nft/) to your simple NFT portfolio dashboard app.\n\nNow, it's time to push your code to production.\n\nBefore doing so, make sure that your API key is stored in a secure place. The best practice for this will be:\n\n- Storing your API key in an environment variable (secrets) `process.env`\n- Have your API called on the backend. While it is possible to call the NFT API on the fronted, it is highly discouraged as it can easily reveal your API key on the browser.\n\nOnce everything checks out, your app is good to go live with [Moralis NFT API](https://moralis.io/api/nft/)! \n",
    "data": {
      "title": "NFT API - Full Guide & Walkthrough",
      "slug": "/guides/nft-api-full-guide-walkthrough",
      "description": "This tutorial teaches you what an NFT API is, what are some of its most common use cases, and how to use it within your tech stack.",
      "tags": [
        "NFT API",
        "Ethereum",
        "Polygon",
        "EVM",
        "ETH NFT API",
        "Polygon NFT API"
      ]
    },
    "isEmpty": false,
    "excerpt": ""
  },
  {
    "content": "## Introduction\n\nThis tutorial shows you how to create a NextJS dapp containing NFT gated functionality. We will create a protected page that's only accessible to users who authenticate and own at least one NFT from the specified NFT collection.\n\nYou can find the repository with the final code [here](https://github.com/MoralisWeb3/demo-apps/tree/main/nextjs_moralis_nft_gating).\n\n![If User Fulfills Requirements - This is the Landing Page](/img/content/dfc9bf3-81e82ad-Untitled.webp)\n\n## Before Starting\n\nYou can start this tutorial if you already have a NextJS dapp with Web3 authorization using `next-auth`. (_Please check our [NextJS Web3 Auth Tutorial](/authentication-api/evm/how-to-sign-in-with-metamask)._)\n\n## NFT Gated Page with `getServerSideProps`\n\n1. Create a new page file, `pages/protected.jsx`, with the following content:\n\n```javascript\nfunction Protected() {\n    return (\n        <div>\n            <h3>Protected content</h3>\n        </div>\n    );\n}\nexport default Protected;\n```\n\n\n\n2. Add the `getServerSideProps` function for checking the user session. In case the user is not authenticated, we will redirect him to the `/signin` page. The message will be returned as a `message` prop and displayed on the client side:\n\n```javascript\nimport { getSession } from 'next-auth/react';\nimport Moralis from 'moralis';\n\nfunction Protected({ message }) {\n    return (\n        <div>\n            <h3>Protected content</h3>\n            <p>{message}</p>\n        </div>\n    );\n}\n\nexport async function getServerSideProps(context) {\n    const session = await getSession(context);\n\n    if (!session) {\n        return {\n            redirect: {\n                destination: '/signin',\n                permanent: false,\n            },\n        };\n    }\n\n\n    return {\n        props: {\n            message:\n                // if user has at least one NFT he will get congrats message\n                nftList.raw.total > 0 ? 'Nice! You have our NFT' : \"Sorry, you don't have our NFT\",\n        },\n    };\n}\nexport default Protected;\n```\n\n\n\n:::info \n\nThe `getServerSideProps` only runs on the server side and never runs on the browser. When you request a page, `getServerSideProps` runs at request time, and this page will be pre-rendered with the returned props.\n\n:::\n\n3. Extend `getServerSideProps` . We will get the user wallet address from the user session object and check if the user has at least one specific NFT using `Moralis.EvmApi`:\n\n```javascript\nimport { getSession } from 'next-auth/react';\nimport Moralis from 'moralis';\nimport { EvmChain } from '@moralisweb3/common-evm-utils';\n\nfunction Protected({ message, nftList }) {\n    return (\n        <div>\n            <h3>Protected content</h3>\n            <p>{message}</p>\n            <pre>{JSON.stringify(nftList, null, 2)}</pre>\n        </div>\n    );\n}\n\nexport async function getServerSideProps(context) {\n    const session = await getSession(context);\n\n    if (!session) {\n        return {\n            redirect: {\n                destination: '/signin',\n                permanent: false,\n            },\n        };\n    }\n\n    if(!Moralis.Core.isStarted){\n        await Moralis.start({ apiKey: process.env.MORALIS_API_KEY });\n    }\n\n    const nftList = await Moralis.EvmApi.nft.getWalletNFTs({\n      \tchain: EvmChain.ETHEREUM,\n        address: session.user.address,\n        // replace \"0x...\" with your NFT token address\n        tokenAddresses: [\"0x...\", ],\n    });\n\n    return {\n        props: {\n            message:\n                // if user has at least one NFT he will get protected content\n                nftList.raw.total > 0 ? 'Nice! You have our NFT' : \"Sorry, you don't have our NFT\",\n            nftList: nftList.raw.result,\n        },\n    };\n}\nexport default Protected;\n```\n\n\n\n4. Visit the [`http://localhost:3000/protected`](http://localhost:3000/protected`) page to test the NFT gated functionality. ([`http://localhost:3000/signin`](http://localhost:3000/signin`) for authentication.)\n\n![Protected Page if User Does Not Fulfill Requirements](/img/content/f8b4e79-Untitled.webp)\n\n![Protected Page When the User is Authenticated and Holds Specified NFT](/img/content/81e82ad-Untitled.webp)",
    "data": {
      "title": "Token Gating Website (NextJS)",
      "slug": "/guides/token-gating-website-nextjs",
      "description": "This tutorial teaches you how to add NFT gated functionality to your NextJS dapp. You can set the rules using `getServerSide` for each page you want to protect. This tutorial works on almost any blockchain, including Ethereum, Polygon, BNB Smart Chain, Avalanche, Cronos, and many more!",
      "tags": ["NFT API", "Demos"]
    },
    "isEmpty": false,
    "excerpt": ""
  },
  {
    "content": "## Introduction\n\nThis tutorial teaches you how to create your very own Micro Blogger Dapp powered by Solana Smart contract and [Moralis Auth API](/authentication-api/solana).\n\nOnce complete, you can use this dapp to create blog posts on Solana Blockchain.\n\nThis is what the final application looks like. You can enter the text in the input and click on the \"Post Blog\" button to process the transaction.\n\n![Final APP UI](/img/content/aa60ae2-image.webp)\n\nYou can find the repository with the final code here: [Solana-Micro-Blogger](https://github.com/JohnVersus/solana-dapp-micro-blog).\n\n## Step1: Deploy Contract\n\nStart a new rust library project named micro_blog\n\n```shell\ncargo init micro_blog --lib\n\ncd micro_blog\n```\n\n\n\nUpdate `Cargo.toml` file with required rust library configurations\n\n```toml\n[lib]\nname = \"micro_blog\"\ncrate-type = [\"cdylib\", \"lib\"]\n```\n\n\n\nInstall the `solana_program` and `borsh` package using\n\n```shell\ncargo add solana_program\ncargo add borsh\n```\n\n\n\nThis is the code for the Micro Blogger solana program. With this code, we will keep track of the number of blogs a wallet has posted and we will log the Blog content and counter to the transaction logs to access it from the client side. Paste this code in `lib.rs` file.\n\n```rs lib.rs\nuse borsh::{BorshDeserialize, BorshSerialize};\nuse std::str;\n\nuse solana_program::{\n    account_info::AccountInfo, entrypoint, entrypoint::ProgramResult, msg,\n    program_error::ProgramError, pubkey::Pubkey,\n};\n\n// Create a struct to store Blog count\n#[derive(BorshSerialize, BorshDeserialize, Debug)]\npub struct BlogCount {\n    pub total_blogs: u32,\n}\n\n// Function to convert buffer array back to string\npub fn buffer_to_string(buffer: &[u8]) -> &str {\n    let s = match str::from_utf8(buffer) {\n        Ok(v) => v,\n        Err(e) => panic!(\"Invalid UTF-8 sequence: {}\", e),\n    };\n    return s;\n}\n\nentrypoint!(micro_blog);\n\npub fn micro_blog(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    instruction_data: &[u8],\n) -> ProgramResult {\n    let data = buffer_to_string(&instruction_data);\n\n    let account = &accounts[0];\n\n    // Check if the account is owned by this program, else throw an error.\n    if account.owner != program_id {\n        msg!(\n            \"Account {:?} does not have the program id {} as owner\",\n            account,\n            program_id\n        );\n        return Err(ProgramError::IncorrectProgramId);\n    }\n\n    // Increment and store the number of times user created a new blog.\n    let mut blog_counter = BlogCount::try_from_slice(&account.data.borrow())?;\n    blog_counter.total_blogs += 1;\n    blog_counter.serialize(&mut &mut account.data.borrow_mut()[..])?;\n\n    // Save the data to the transaction logs\n    msg!(\"Author: {}\", accounts[1].key);\n    msg!(\"Blog No: {}\", blog_counter.total_blogs);\n    msg!(\"Blog: {}\", data);\n\n    Ok(())\n}\n\n```\n\n\n\nBuild the Solana Rust Program using\n\n```bash\ncargo build-bpf\n```\n\n\n\nOnce built successfully without any error `.so` of the program will be added to the `/target/deploy` folder. You can deploy this to the solana cluster using.\n\n```shell\nsolana program deploy ./target/deploy/micro_blog.so\n```\n\n\n\nOnce successfully deployed it will return the program Id of the Solana Program.\n\n![Console with Program Id](/img/content/a01aaa2-image.webp)\n\nStore the Program Id somewhere accessible, as we will need this to call the smart contract function from the client side.\n\n## Step2: Frontend Setup\n\nFollow these steps to run the project in your local environment.\n\n- Clone the project from [GitHub](https://github.com/JohnVersus/solana-dapp-micro-blog) using the`git clone` command and `cd` into the project\n\n```shell\ngit clone https://github.com/JohnVersus/solana-dapp-micro-blog.git\n\ncd solana-dapp-micro-blog\n```\n\n\n\n- Install the dependencies using the`yarn` or `npm` package manager.\n\n```shell\nyarn install\n```\n\n\n\n- Rename `.env.local.example` file to `.env.local` and add the required environment secrets.\n\n```shell .env.local\nAPP_CHAIN_ID=devnet\nAPP_DOMAIN=ethereum.boilerplate \nMORALIS_API_KEY= xxx\nNEXTAUTH_SECRET= # Linux: `openssl rand -hex 32` or go to https://generate-secret.now.sh/64\nNEXTAUTH_URL=http://localhost:3000\n\n```\n\n\n\n- Start the app in localhost port 3000.\n\n```shell\nyarn run dev\n```\n\n\n\nOnce the command has been run successfully, you should be able to view the app in localhost port 3000, or click [here](http://localhost:3000) to open the page directly.\n\nIn the app, you'll find multiple tabs, but for this tutorial, we only need to access the `/microBlog` page to create new blog posts. \n\n![Nav Bar](/img/content/806136a-image.webp)\n\nTo use the app, we must first connect to the Solana wallet. This can be done by clicking the \"Select Wallet\" button on the top right. You can then connect to the wallet of your choice. \n\n![Wallet Connect Button](/img/content/5e9b822-image.webp)\n\nThe code related to authentication can be found in the `src/components/modules/ConnectButton` folder, although we won't be looking at the authentication code in this tutorial. \n\nIf you want to know how authentication works, you can take a look at this [video](https://www.youtube.com/watch?v=0fuevxebv_E). \n\n## Step3: Calling the Smart Contract\n\nThe first step of the app is to add the program Id of the solana contract and initiate a devnet cluster connection, where we will test the app.\n\n> Only partical code is shown here to keep it clean. Visit  `src/components/templates/microBlog` to view the entire code.\n\n```typescript MicroBlog.tsx\nconst programId = 'xxx';\nconst connection = new Connection(clusterApiUrl('devnet'));\n```\n\n\n\nThe next part of the code is used to create a new PDA account unique for the user that stores the blog counter data on the chain and the same code will also initiate a transaction to create a new blog post. \n\n```typescript MicroBlog.tsx\n// Refer full code in `src/components/templates/microBlog/MicroBlog.tsx`\n\n// `createBlog` function is triggered with a button click from frontend.\n  const createBlog = async () => {\n    // Account Creation --- Start\n    const SEED = 'secret_phrase_to_recover_account_address';\n    class BlogCount {\n      total_blogs = 0;\n      constructor(fields: { total_blogs: number } | undefined = undefined) {\n        if (fields) {\n          this.total_blogs = fields.total_blogs;\n        }\n      }\n    }\n    const BlogSchema = new Map([\n      [\n        BlogCount,\n        {\n          kind: 'struct',\n          fields: [['total_blogs', 'u32']],\n        },\n      ],\n    ]);\n    const DATA_SIZE = borsh.serialize(BlogSchema, new BlogCount()).length;\n    const accountPubkey = await PublicKey.createWithSeed(publicKey, SEED, new PublicKey(programId));\n    const blogAccount = await connection.getAccountInfo(accountPubkey);\n\n    if (blogAccount === null) {\n      const lamports = await connection.getMinimumBalanceForRentExemption(DATA_SIZE);\n      // Transaction for account creation\n      const AccountCreation = new Transaction();\n      AccountCreation.add(\n        SystemProgram.createAccountWithSeed({\n          fromPubkey: publicKey,\n          basePubkey: publicKey,\n          seed: SEED,\n          newAccountPubkey: accountPubkey,\n          lamports,\n          space: DATA_SIZE,\n          programId: new PublicKey(programId),\n        }),\n      );\n      const {\n        context: { slot: minContextSlot },\n        value: { blockhash, lastValidBlockHeight },\n      } = await connection.getLatestBlockhashAndContext();\n\n      const signature = await sendTransaction(AccountCreation, connection, {\n        minContextSlot,\n        skipPreflight: true,\n        signers: [],\n        preflightCommitment: 'processed',\n      });\n      const confirmtx = await connection.confirmTransaction({ blockhash, lastValidBlockHeight, signature });\n    }\n    // Account Creation --- END\n\n    // Transaction to post a new blog\n    const transaction = new Transaction();\n    setStatus('Processing Transaction');\n    transaction.add(\n      new TransactionInstruction({\n        keys: [\n          {\n            pubkey: accountPubkey,\n            isSigner: false,\n            isWritable: true,\n          },\n          {\n            pubkey: publicKey,\n            isSigner: true,\n            isWritable: false,\n          },\n          {\n            pubkey: SystemProgram.programId,\n            isSigner: false,\n            isWritable: false,\n          },\n        ],\n        programId: new PublicKey(programId),\n        data: Buffer.from(blogInupt),\n      }),\n    );\n\n    const {\n      context: { slot: minContextSlot },\n      value: { blockhash, lastValidBlockHeight },\n    } = await connection.getLatestBlockhashAndContext();\n\n    try {\n      const signature = await sendTransaction(transaction, connection, {\n        minContextSlot,\n        skipPreflight: true,\n        signers: [],\n        preflightCommitment: 'processed',\n      });\n\n      const confirmtx = await connection.confirmTransaction({ blockhash, lastValidBlockHeight, signature });\n      await connection.getParsedTransaction(signature);\n      getAllTransactions();\n    } catch (e) {\n      console.log(e);\n    }\n  };\n\n// `getAllTransactions` function is invoked after a new blog is created,\n// and the new data processed and updated in the UI\n  const getAllTransactions = async () => {\n    const data = await connection.getSignaturesForAddress(new PublicKey(programId));\n=  };\n\n```\n\n\n\nAnd there we have it! That's all the code required to create a transaction to call the solana contract and to post the data on the chain.\n\n## Step4: Testing\n\nThe dapp can be tested by visiting the `/microBlog` page. Add the text that you want to store on the blockchain and click on the \"Post Blog\" button. \n\n![Input to add new post](/img/content/7e45d97-image.webp)\n\nWhen posting the first blog you will have to sign two transactions. One for creating the account and the other for creating the blog post. Once the transactions are successful. You should see the blog updated in the UI, with the Blog number.\n\n![Blog Post](/img/content/627ed01-image.webp)\n\nCongratulations!  \n\nNow you know how to create your very own Solana Micro Blogger dapp to create blog posts in the blockchain.\n\n## Support\n\nIf you have any trouble following the tutorial, feel free to reach out to our community engineers in our [Discord](https://moralis.io/discord) or [Forum](https://forum.moralis.io) to get 24/7 developer support.",
    "data": {
      "title": "Solana Micro Blogger Dapp",
      "slug": "/guides/solana-micro-blogger-dapp",
      "description": "This tutorial teaches you how to create your very own Micro Blogger Dapp powered by Solana Smart contract and Moralis",
      "tags": ["Authentication API", "Solana API", "Demos"]
    },
    "isEmpty": false,
    "excerpt": ""
  },
  {
    "content": "## Introduction\n\nThis tutorial teaches you how to create your very own Multiplayer Tic Tac Toe game powered by Solana Smart contract and [Moralis Auth API](/authentication-api/solana).\n\nOnce complete, you can use this dapp to create new games with other players and play the game in real-time.\n\nThis is what the final application looks like. \n\n![Tic Tac Toe Board](/img/content/3901379-image.webp)\n\nYou can find the repository with the final code here: [Tic-Tac-Toe](https://github.com/JohnVersus/solana-dapp-tic-tac-toe).\n\n## Step 1: Deploy Contract\n\nStart a new rust library project named micro_blog\n\n```shell\ncargo init tic_tac_toe --lib\n\ncd tic_tac_toe\n```\n\n\n\nUpdate `Cargo.toml` file with required rust library configurations\n\n```toml\n[lib]\nname = \"tic_tac_toe\"\ncrate-type = [\"cdylib\", \"lib\"]\n```\n\n\n\nInstall the `solana_program` and `borsh` package using\n\n```shell\ncargo add solana_program\ncargo add borsh\n```\n\n\n\nThis is the code for the Tic Tac Toe solana program. With this code, we can create new games between the user, play games, and store the game data on the blockchain. Paste the below code in `lib.rs` file.\n\n```rs lib.rs\nuse borsh::{BorshDeserialize, BorshSerialize};\nuse solana_program::{\n    account_info::AccountInfo, entrypoint, entrypoint::ProgramResult, msg, pubkey::Pubkey,\n};\n\npub fn win_check(moves: [u32; 9]) -> u32 {\n    // Player 1 move will be marked as 1 and player 2 as 2\n    let [m1, m2, m3, m4, m5, m6, m7, m8, m9] = moves;\n    if (m1 == 1 && m2 == 1 && m3 == 1)\n        || (m1 == 1 && m4 == 1 && m7 == 1)\n        || (m7 == 1 && m8 == 1 && m9 == 1)\n        || (m3 == 1 && m6 == 1 && m9 == 1)\n        || (m1 == 1 && m5 == 1 && m9 == 1)\n        || (m3 == 1 && m5 == 1 && m7 == 1)\n        || (m2 == 1 && m5 == 1 && m8 == 1)\n        || (m4 == 1 && m5 == 1 && m6 == 1)\n    {\n        // Condition for Player 1 Win\n        return 1;\n    } else if (m1 == 2 && m2 == 2 && m3 == 2)\n        || (m1 == 2 && m4 == 2 && m7 == 2)\n        || (m7 == 2 && m8 == 2 && m9 == 2)\n        || (m3 == 2 && m6 == 2 && m9 == 2)\n        || (m1 == 2 && m5 == 2 && m9 == 2)\n        || (m3 == 2 && m5 == 2 && m7 == 2)\n        || (m2 == 2 && m5 == 2 && m8 == 2)\n        || (m4 == 2 && m5 == 2 && m6 == 2)\n    {\n        // Condition for Player 2 Win\n        return 2;\n    } else if (m1 == 1 || m1 == 2)\n        && (m2 == 1 || m2 == 2)\n        && (m3 == 1 || m3 == 2)\n        && (m4 == 1 || m4 == 2)\n        && (m5 == 1 || m5 == 2)\n        && (m6 == 1 || m6 == 2)\n        && (m7 == 1 || m7 == 2)\n        && (m8 == 1 || m8 == 2)\n        && (m9 == 1 || m9 == 2)\n    {\n        // Condition for Draw\n        return 3;\n    } else {\n        return 0;\n    }\n}\n\n#[derive(BorshSerialize, BorshDeserialize, Debug)]\npub struct GameAccount {\n    pub player1: String,\n    pub player2: String,\n    pub moves: [u32; 9],\n    pub game_status: u32,\n    pub next_move: u32,\n}\n\nentrypoint!(tic_tac_toe);\n\npub fn tic_tac_toe(\n    _program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    instruction_data: &[u8],\n) -> ProgramResult {\n    let game_account = &accounts[0];\n    let player1 = accounts[1].key.to_string();\n    let player2 = accounts[2].key.to_string();\n\n    let instruction: u32 = instruction_data[0].into();\n    let played_by: u32 = instruction_data[1].into();\n    let move_positon: usize = instruction_data[2].into();\n\n    match instruction {\n        // Create New Game or Reset the Game Data\n        0 => {\n            msg!(\"Instruction 0 Start\");\n            let game_data = GameAccount {\n                player1,\n                player2,\n                moves: [0, 0, 0, 0, 0, 0, 0, 0, 0],\n                game_status: 0,\n                next_move: 1,\n            };\n            msg!(\"Game Creation Successful!!\");\n            msg!(\"Player 1: {:?}\", game_data.player1);\n            msg!(\"Player 2: {:?}\", game_data.player2);\n            game_data.serialize(&mut &mut game_account.data.borrow_mut()[..])?;\n            msg!(\"Instruction 0 End\");\n        }\n        // Play game!!\n        1 => {\n            msg!(\"Instruction 1 Start\");\n            let mut game_data = GameAccount::try_from_slice(&game_account.data.borrow())?;\n            if game_data.game_status == 0 {\n                msg!(\"Player 1: {:?}\", game_data.player1);\n                msg!(\"Player 2: {:?}\", game_data.player2);\n\n                // Verify and updating moves in Game Account\n                if (game_data.moves[move_positon] == 0) && (game_data.next_move == played_by) {\n                    if game_data.next_move == 1 {\n                        game_data.moves[move_positon] = 1;\n                        game_data.next_move = 2\n                    } else if game_data.next_move == 2 {\n                        game_data.moves[move_positon] = 2;\n                        game_data.next_move = 1\n                    }\n                } else {\n                    msg!(\" Wrong Move\");\n                }\n\n                let game_status = win_check(game_data.moves);\n\n                match game_status {\n                    0 => {\n                        // Log the next player to move\n                        msg!(\"Next move: Player {}\", game_data.next_move);\n                    }\n                    1 => {\n                        game_data.game_status = 1;\n                        msg!(\"Player 1 won the game.\");\n                    }\n                    2 => {\n                        game_data.game_status = 2;\n                        msg!(\"Player 2 won the game.\");\n                    }\n                    3 => {\n                        game_data.game_status = 3;\n                        msg!(\"It's a Draw.\");\n                    }\n                    _ => {\n                        msg!(\"Game Error!!\");\n                    }\n                }\n                // Write the updated data to account.\n                game_data.serialize(&mut &mut game_account.data.borrow_mut()[..])?;\n                msg!(\"Instruction 1 End\");\n            } else {\n                msg!(\" Wrong Move.\");\n            }\n        }\n        // Invalid Instruction\n        _ => {\n            msg!(\"Invalid Instruction\");\n        }\n    }\n\n    Ok(())\n}\n```\n\n\n\nBuild the Solana Rust Program using\n\n```bash\ncargo build-bpf\n```\n\n\n\nOnce built successfully without any error `.so` of the program will be added to the `/target/deploy` folder. You can deploy this to the solana cluster using.\n\n```shell\nsolana program deploy ./target/deploy/tic_tac_toe.so\n```\n\n\n\nOnce successfully deployed it will return the program Id of the Solana Program.\n\n![Console with Program Id](/img/content/5d366aa-image.webp)\n\nStore the Program Id somewhere accessible, as we will need this to call the smart contract function from the client side.\n\n## Step 2: Frontend Setup\n\nFollow these steps to run the project in your local environment.\n\n- Clone the project from [GitHub](https://github.com/JohnVersus/solana-dapp-tic-tac-toe) using the`git clone` command and `cd` into the project\n\n```shell\ngit clone https://github.com/JohnVersus/solana-dapp-tic-tac-toe.git\n\ncd solana-dapp-tic-tac-toe\n```\n\n\n\n- Install the dependencies using the`yarn` or `npm` package manager.\n\n```shell\nyarn install\n```\n\n\n\n- Rename `.env.local.example` file to `.env.local` and add the required environment secrets.\n\n```shell .env.local\nAPP_CHAIN_ID=devnet\nAPP_DOMAIN=ethereum.boilerplate \nMORALIS_API_KEY= xxx\nNEXTAUTH_SECRET= # Linux: `openssl rand -hex 32` or go to https://generate-secret.now.sh/64\nNEXTAUTH_URL=http://localhost:3000\n\n# Required for signing game transactions\nOWNER_PRIVATE_KEY= xxx\n\nNEXT_PUBLIC_PROGRAM_ID = xxx \n```\n\n\n\n- Start the app in localhost port 3000.\n\n```shell\nyarn run dev\n```\n\n\n\nOnce the command has been run successfully, you should be able to view the app in localhost port 3000, or click [here](http://localhost:3000) to open the page directly.\n\nIn the app, you'll find multiple tabs, but for this tutorial, we only need to access the `/tic-tac-toe` page. \n\n![Nav Bar](/img/content/2e9d40f-image.webp)\n\nTo use the app, we must first connect to the Solana wallet. This can be done by clicking the \"Select Wallet\" button on the top right. You can then connect to the wallet of your choice. \n\n![Select Wallet Button](/img/content/5e9b822-image.webp)\n\nAuthenticating the wallet is important for this dapp so that we can prevent unauthorized gameplay.\n\nThe code related to authentication can be found in the `src/components/modules/ConnectButton` folder, although we won't be looking at the authentication code in this tutorial. \n\nIf you want to know how authentication works, you can take a look at this [video](https://www.youtube.com/watch?v=0fuevxebv_E). \n\n## Step 3: Calling the Smart Contract\n\nIn this project, we are signing all the transactions in the backend using the owner's private key, so that players don't have to sign transactions on every move.\n\nThe code related to this can be found in the `pages/api/TicTacToe` folder.\n\nUsing the `newgame.ts` API route we can sign transactions required to create a new game by taking the player address as input and with `playGame.ts` we can sign transactions required to play the game by taking the player's move as input. \n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n<Tabs>\n<TabItem value=\"newGame.ts\" label=\"newGame.ts\">\n\n```typescript\nimport type { NextApiRequest, NextApiResponse } from 'next';\nimport {\n  Connection,\n  clusterApiUrl,\n  Keypair,\n  PublicKey,\n  Transaction,\n  SystemProgram,\n  sendAndConfirmTransaction,\n  TransactionInstruction,\n} from '@solana/web3.js';\nimport base58 from 'bs58';\nimport * as borsh from 'borsh';\nimport { GameAccount, GameAccountSchema } from 'components/templates/TicTacToe/types';\n\nexport default async function handler(req: NextApiRequest, res: NextApiResponse) {\n  const { OWNER_PRIVATE_KEY } = process.env;\n  const { player1, player2 } = req.body;\n\n  if (!OWNER_PRIVATE_KEY) {\n    throw new Error('Add Owner private key in env file.');\n  }\n  const key = Uint8Array.from(base58.decode(OWNER_PRIVATE_KEY));\n  const keypair = Keypair.fromSecretKey(key);\n  const { publicKey } = keypair;\n\n  const Player1 = player1;\n  const Player2 = player2;\n  const programId = process.env.NEXT_PUBLIC_PROGRAM_ID;\n  if (!programId) {\n    throw new Error('Add Program Id in env file.');\n  }\n  const connection = new Connection(clusterApiUrl('devnet'));\n\n  // Account Creation --- Start\n  const GAME_ACCOUNT_SECRET = `${player1.substring(0, 5)}${player2.substring(0, 5)}`;\n\n  const DATA_SIZE = borsh.serialize(GameAccountSchema, new GameAccount()).length;\n  console.log(DATA_SIZE);\n\n  const GameDataAccountPubkey = await PublicKey.createWithSeed(\n    publicKey,\n    GAME_ACCOUNT_SECRET,\n    new PublicKey(programId),\n  );\n\n  const GameDataAccount = await connection.getAccountInfo(GameDataAccountPubkey);\n\n  if (GameDataAccount === null) {\n    console.log('Creating account', GameDataAccountPubkey.toBase58(), 'to play Tic-Tac-Toe');\n\n    const lamports = await connection.getMinimumBalanceForRentExemption(DATA_SIZE);\n\n    const AccountCreation = new Transaction();\n    AccountCreation.add(\n      SystemProgram.createAccountWithSeed({\n        fromPubkey: publicKey,\n        basePubkey: publicKey,\n        seed: GAME_ACCOUNT_SECRET,\n        newAccountPubkey: GameDataAccountPubkey,\n        lamports,\n        space: DATA_SIZE,\n        programId: new PublicKey(programId),\n      }),\n    );\n    console.log('created AccountWithSeed', AccountCreation);\n    const {\n      context: { slot: minContextSlot },\n      value: { blockhash, lastValidBlockHeight },\n    } = await connection.getLatestBlockhashAndContext();\n\n    const signature = await sendAndConfirmTransaction(connection, AccountCreation, [keypair], {\n      minContextSlot,\n      skipPreflight: true,\n      preflightCommitment: 'processed',\n    });\n    const confirmtx = await connection.confirmTransaction({ blockhash, lastValidBlockHeight, signature });\n    console.log({ signature, confirmtx });\n  }\n  // Account Creation --- END\n\n  const transaction = new Transaction();\n  transaction.add(\n    new TransactionInstruction({\n      keys: [\n        {\n          pubkey: GameDataAccountPubkey,\n          isSigner: false,\n          isWritable: true,\n        },\n        {\n          pubkey: new PublicKey(Player1),\n          isSigner: false,\n          isWritable: false,\n        },\n        {\n          pubkey: new PublicKey(Player2),\n          isSigner: false,\n          isWritable: false,\n        },\n        {\n          pubkey: publicKey,\n          isSigner: true,\n          isWritable: false,\n        },\n        {\n          pubkey: SystemProgram.programId,\n          isSigner: false,\n          isWritable: false,\n        },\n      ],\n      programId: new PublicKey(programId),\n      data: Buffer.from([0, 0, 0]),\n    }),\n  );\n\n  const {\n    context: { slot: minContextSlot },\n    value: { blockhash, lastValidBlockHeight },\n  } = await connection.getLatestBlockhashAndContext();\n\n  try {\n    const signature = await sendAndConfirmTransaction(connection, transaction, [keypair], {\n      minContextSlot,\n      skipPreflight: true,\n      preflightCommitment: 'processed',\n    });\n\n    const confirmtx = await connection.confirmTransaction({ blockhash, lastValidBlockHeight, signature });\n    console.log({ signature, confirmtx });\n    const data = await connection.getParsedTransaction(signature);\n\n    res.status(200).json(data);\n  } catch (error) {\n    if (error instanceof Error) {\n      res.status(400).send(error.message);\n      console.error(error.message);\n    }\n  }\n}\n\n```\n\n</TabItem>\n<TabItem value=\"playGame.ts\" label=\"playGame.ts\">\n\n```typescript\nimport type { NextApiRequest, NextApiResponse } from 'next';\nimport {\n  Connection,\n  clusterApiUrl,\n  Keypair,\n  PublicKey,\n  Transaction,\n  SystemProgram,\n  sendAndConfirmTransaction,\n  TransactionInstruction,\n} from '@solana/web3.js';\nimport base58 from 'bs58';\n\nexport default async function handler(req: NextApiRequest, res: NextApiResponse) {\n  const { OWNER_PRIVATE_KEY } = process.env;\n  const { player1, player2, gamePlayer, move } = req.body;\n  if (!OWNER_PRIVATE_KEY) {\n    throw new Error('Add Owner private key in env file.');\n  }\n  const key = Uint8Array.from(base58.decode(OWNER_PRIVATE_KEY));\n  const keypair = Keypair.fromSecretKey(key);\n  const { publicKey } = keypair;\n\n  const Player1 = player1;\n  const Player2 = player2;\n  const programId = process.env.NEXT_PUBLIC_PROGRAM_ID;\n  if (!programId) {\n    throw new Error('Add Program Id in env file.');\n  }\n  const connection = new Connection(clusterApiUrl('devnet'));\n\n  const GAME_ACCOUNT_SECRET = `${player1.substring(0, 5)}${player2.substring(0, 5)}`;\n\n  const GameDataAccountPubkey = await PublicKey.createWithSeed(\n    publicKey,\n    GAME_ACCOUNT_SECRET,\n    new PublicKey(programId),\n  );\n\n  const transaction = new Transaction();\n  transaction.add(\n    new TransactionInstruction({\n      keys: [\n        {\n          pubkey: GameDataAccountPubkey,\n          isSigner: false,\n          isWritable: true,\n        },\n        {\n          pubkey: new PublicKey(Player1),\n          isSigner: false,\n          isWritable: false,\n        },\n        {\n          pubkey: new PublicKey(Player2),\n          isSigner: false,\n          isWritable: false,\n        },\n        {\n          pubkey: publicKey,\n          isSigner: true,\n          isWritable: false,\n        },\n        {\n          pubkey: SystemProgram.programId,\n          isSigner: false,\n          isWritable: false,\n        },\n      ],\n      programId: new PublicKey(programId),\n      data: Buffer.from([1, gamePlayer, move]),\n    }),\n  );\n\n  const {\n    context: { slot: minContextSlot },\n    value: { blockhash, lastValidBlockHeight },\n  } = await connection.getLatestBlockhashAndContext();\n\n  try {\n    const signature = await sendAndConfirmTransaction(connection, transaction, [keypair], {\n      minContextSlot,\n      skipPreflight: true,\n      preflightCommitment: 'processed',\n    });\n    const confirmtx = await connection.confirmTransaction({ blockhash, lastValidBlockHeight, signature });\n    const data = await connection.getParsedTransaction(signature);\n\n    res.status(200).json(data?.meta?.logMessages);\n  } catch (error) {\n    if (error instanceof Error) {\n      res.status(400).send(error.message);\n      console.error(error.message);\n    }\n  }\n}\n\n```\n\n</TabItem>\n</Tabs>\n\nHere is the code related to the frontend code.\n\n> Only partial code is shown here to keep it clean. Visit `src/components/templates/TicTacToe` to view the entire code.\n\nThe first step of the game is to create a new game to play using this `Create Game` tab.\n\n![](/img/content/1e15cd8-image.webp)\n\nThe code in `NewGameForm.tsx` files are responsible for reading the data from new game inputs and sending the data to the backend `newGame` API route for signing the transaction. \n\n```typescript NewGameForm.tsx\n// Refer full code in `src/components/templates/TicTacToe/NewGameForm.tsx`\n\nconst NewGameForm: FC = () => {\n  // Player data from frontend is stored in state variables\n  const [player2, setPlayer2] = useState('');\n\n  const handleInput = (e: ChangeEvent<HTMLInputElement>) => {\n    setPlayer2(e.target.value);\n  };\n  const { publicKey } = useWallet();\n  const createGame = async () => {\n    if (!publicKey || !player2) {\n    }\n    if (publicKey?.toBase58() === player2) {\n    }\n    const players = {\n      player1: publicKey,\n      player2: new PublicKey(player2),\n    };\n    try {\n      // Callign the `newGame` api route to create a new game with players data\n      const data = await apiPost('/TicTacToe/newGame', players);\n    } catch (e) {\n      if (e instanceof Error) {\n        console.log(e.message);\n      }\n    }\n  };\n\n  return (\n    <>\n      <FormControl>\n        <Flex height={'300px'} direction={'column'} alignItems={'center'} justifyContent={'space-around'}>\n          <Box width={'50%'}>\n            <FormLabel>Player 1</FormLabel>\n            <Input placeholder=\"Connect to Wallet\" value={`${publicKey ? publicKey : ''}`} disabled />\n          </Box>\n          <Box width={'50%'}>\n            <FormLabel>Player 2</FormLabel>\n            <Input placeholder=\"Player 2 Address\" onChange={handleInput} />\n          </Box>\n          <Button width={'50%'} mt={4} colorScheme=\"teal\" isLoading={status ? true : false} onClick={createGame}>\n            Create New Game\n          </Button>\n          <FormHelperText>{status && status}</FormHelperText>\n        </Flex>\n      </FormControl>\n    </>\n  );\n};\n```\n\n\n\nWhen a transaction for the new game is successful. We can visit `Play Game` tab to play the game. Clicking the `Refresh Games` button will load the created games. \n\n![Play Game Tab](/img/content/e0e1bd3-image.webp)\n\n![Play Game Tab with refreshed Games](/img/content/7166cee-image.webp)\n\nThe code related to getting the games from the blockchain can be found in the `src/components/templates/TicTacToe/TicTacToe.tsx`\n\n```typescript TicTacToe.tsx\n// Refer full code in `src/components/templates/TicTacToe/TicTacToe.tsx`\n\n// Data of available game accounts are stored in state variable\nconst [gameAccounts, setGameAccounts] = useState<Array<gameData['data']>>([]);\n\n// `getProgramAccounts` function is called when then Refresh games button is clicked\nconst getProgramAccounts = async () => {\n    setGameAccounts([]);\n    const data = await connection.getProgramAccounts(new PublicKey(programId));\n    if (data.length) {\n      data.forEach((e) => {\n        console.log(e);\n        const gameInput = deserializeUnchecked(GameAccountSchema, GameAccount, e.account.data);\n        const accountId = e.pubkey;\n        const game = { gameInput, accountId };\n        console.log(data);\n        setGameAccounts((existing) => [...existing, game]);\n      });\n  };\n\nreturn (\n  <Flex flexDirection={'column'} alignItems={'center'}>\n    <Heading size=\"sm\" marginBottom={6}>\n      {gameAccounts.length ? 'Available Games!!' : 'Click to refresh games'}\n    </Heading>\n    <Flex overflow={'scroll'} maxWidth={'800px'} gap={'4px'}>\n     // UI is rendered with the data from `gameAccounts` stae\n      {gameAccounts &&\n        gameAccounts.map((game, i) => {\n          return (\n            <Games\n              key={i}\n              data={{ gameInput: game.gameInput, accountId: game.accountId }}\n              loadGame={() => {\n                loadGame(game);\n              }}\n            />\n          );\n        })}\n    </Flex>\n    <Button\n      maxWidth={'200px'}\n      minWidth={'150px'}\n      mt={4}\n      colorScheme=\"gray\"\n      isLoading={status ? true : false}\n      onClick={getProgramAccounts}\n    >\n      Refresh Games\n    </Button>\n  </Flex>\n);\n```\n\n\n\nThe next step of the game is to play the games that can be loaded by selecting one of the available games. And you can play the game by clicking on any of the boxes from Tic Tac Toe board. \n\nThe below is code that handles the gameplay and signs the transaction of the gameplay. It has 3 important functions.\n\n- `playGame` function - When a user clicks on any box. The play game function collects the data like which box is clicked and who clicked the box and send it to the backend `playGame` API route to sign the transactions. \n- `connection.onAccountChange()` function - listens to the change in-game account data. We pass a callback to this listener function to get the updated data and update our UI with the latest data. \n- `celebrateWin` function - Check the latest game data for a winner and shows a notification if there is a winner. \n\nThese 3 functions are responsible for the gameplay on the frontend. \n\n```typescript GameBoard.tsx\n// Refer full code in `src/components/templates/TicTacToe/GameBoard.tsx`\n\nconst GameBoard: FC<BoardInput> = ({ data, connection }) => {\n  const { publicKey } = useWallet();\n  const toast = useToast();\n  const [currentgameData, setCurrentGameData] = useState<GameAccount>();\n  const [subscriptions, SetSubscriptions] = useState<number[]>([]);\n  const [spinner, setSpinner] = useState<number | null>();\n\n  const accountPublicKey = data.accountId;\n\n  useEffect(() => {\n    setCurrentGameData(data.gameInput);\n  }, [data]);\n\n  // Listen to account changes\n  useEffect(() => {\n    const SubId = connection.onAccountChange(accountPublicKey, (e) => {\n      console.log(e);\n      const gameInput = deserializeUnchecked(GameAccountSchema, GameAccount, e.data);\n      setCurrentGameData(gameInput);\n    });\n    SetSubscriptions((existing) => [...existing, SubId]);\n    console.log(SubId);\n  }, [accountPublicKey]);\n\n  useEffect(() => {\n    console.log(subscriptions);\n    if (subscriptions.length > 1) {\n      connection.removeAccountChangeListener(subscriptions[0]);\n      deleteArrayElement(subscriptions[0]);\n    }\n  }, [subscriptions]);\n\n  const celebrateWin = (winnerId: number) => {\n    switch (winnerId) {\n      case 1: {\n        if (currentgameData?.player1 === publicKey?.toBase58()) {\n          toast({\n            title: 'You won the game!! ',\n            status: 'success',\n            position: 'bottom-right',\n            isClosable: true,\n          });\n        } else {\n          toast({\n            title: 'Player 1 won the game!! ',\n            status: 'error',\n            position: 'bottom-right',\n            isClosable: true,\n          });\n        }\n        break;\n      }\n      case 2: {\n        if (currentgameData?.player2 === publicKey?.toBase58()) {\n          toast({\n            title: 'You won the game!! ',\n            status: 'success',\n            position: 'bottom-right',\n            isClosable: true,\n          });\n        } else {\n          toast({\n            title: 'Player 2 won the game!! ',\n            status: 'error',\n            position: 'bottom-right',\n            isClosable: true,\n          });\n        }\n        break;\n      }\n      case 3: {\n        toast({\n          title: 'Its a Draw!! ',\n          status: 'success',\n          position: 'bottom-right',\n          isClosable: true,\n        });\n\n        break;\n      }\n    }\n  };\n\n  async function playGame(move: number) {\n    if (currentgameData) {\n      const gamePlayer =\n        currentgameData.player1 === publicKey?.toBase58()\n          ? 1\n          : currentgameData.player2 === publicKey?.toBase58()\n          ? 2\n          : 0;\n      if (gamePlayer) {\n          const gameMove = { player1: currentgameData.player1, player2: currentgameData.player2, gamePlayer, move };\n          await apiPost('/TicTacToe/playGame', gameMove);\n    }\n  }\n\n  if (currentgameData) {\n    return (\n      <>\n        <Flex>\n          <Grid gridTemplateColumns={'repeat(3, 1fr)'} gridTemplateRows={'repeat(3, 1fr)'} justifyContent={'center'}>\n            {currentgameData.moves.map((e, i) => {\n              return (\n                <Flex\n                  onClick={() => { playGame(i);}\n                  fontSize={'25px'}\n                  color={'white'}\n                  cursor={'pointer'}\n                >\n                  {(e === 1 && '') || (e === 2 && '') || (e === 0 && (spinner === i ? <Spinner /> : ''))}\n                </Flex>\n              );\n            })}\n          </Grid>\n        </Flex>\n      </>\n    );\n  }\n  return null;\n};\n\n```\n\n\n\nApart from the above code, you may find multiple `if` conditions in the `GameBoard.tsx` code. Those conditions are responsible for valid gameplay so that we don't send the unnecessary move to the backend to sign the gamePlay transactions, which results in failed transactions and costs unnecessary gas.\n\nThat's the end of it!! \n\nThat's all the code required to create and play a Multi-player Tic-Tac-Toe game.\n\n## Step 4: Testing\n\nThe game can be tested by first creating a new game in `Create Game` tab and then visit `Play Game` to refresh the games. Now by selecting the game you can start playing it with other players.\n\nCongratulations!  \n\nNow you know how to create your very own Multi-Player Tic Tac Toe game on the solana blockchain.\n\n## Support\n\nIf you have any trouble following the tutorial, feel free to reach out to our community engineers in our [Discord](https://moralis.io/discord) or [Forum](https://forum.moralis.io) to get 24/7 developer support.",
    "data": {
      "title": "Solana Multiplayer Game - TicTacToe",
      "slug": "/guides/solana-multiplayer-game-tictactoe",
      "description": "This tutorial teaches you how to create your very own Multiplayer Tic Tac Toe game powered by Solana Smart contract and Moralis",
      "tags": ["Solana API", "Authentication API", "Demos"]
    },
    "isEmpty": false,
    "excerpt": ""
  },
  {
    "content": "## Introduction\n\nThis tutorial teaches you how to create your very own NFT burner dapp in NextJS using Metaplex JS SDK, and the Moralis API.\n\nOnce complete, you can use this dapp to burn spam or unwanted NFTs from your wallet in just a few clicks, and burning Solana NFTs also returns back Solana to your wallet.\n\n#### Why Does Burning Solana NFTs Give You Solana Tokens Back?\n\nSolana blockchain has this concept called \"Rent\" that should be paid every time we store data in the Solana account. When we [mint new NFTs](/guides/solana-nft-minter) we pay the rent through a transaction fee. \n\nWhen we burn NFTs, the Solana program returns back the remaining rent in the NFT account to the current NFT owner. So, even by burning spam or unwanted NFTs, we can recover some Solana tokens from NFT accounts.  \n\nIn this project, we will use [Metaplex JavaScript SDK](https://github.com/metaplex-foundation/js) to burn and the [Moralis API](/web3-data-api/solana/how-to-get-native-solana-balance-by-wallet) to view the NFTs.\n\nThis is what the final application looks like. You can click on any NFTs in your wallet that you want to remove and click on the burn button to burn the NFT.\n\n![Final App UI](/img/content/c37a205-image.webp)\n\nInstead of going through the entire code, we will focus on the important sections of code that power the application. \n\nYou can find the repository with the final code here: [Solana-NFT-Burner](https://github.com/JohnVersus/solana-nft-burner).\n\n## Step1: Project Setup\n\nFollow these steps to run the project in your local environment.\n\n- Clone the project from [GitHub](https://github.com/JohnVersus/solana-nft-burner) using the`git clone` command and `cd` into the project\n\n```shell\ngit clone https://github.com/JohnVersus/solana-nft-burner.git\n\ncd solana-nft-burner\n```\n\n\n\n- Install the dependencies using the`yarn` or `npm` package manager.\n\n```shell\nyarn install\n```\n\n\n\n- Rename `.env.local.example` file to `.env.local` and add the required environment secrets.\n\n```shell .env.local\n# devent is used for chain Id as we will be testing the app on devnet chain\nAPP_CHAIN_ID=devnet\nAPP_DOMAIN=ethereum.boilerplate \n\n# Get your KEY https://admin.moralis.io/web3api\nMORALIS_API_KEY= xxx\n\n# Linux: `openssl rand -hex 32` or go to https://generate-secret.now.sh/64\nNEXTAUTH_SECRET= xxx\n\n# Replace for production\nNEXTAUTH_URL=http://localhost:3000\n\n# Wallet private only if you want to use the NFT Minter page.\nPRIVATE_KEY = xxx\n```\n\n\n\n- Start the app in localhost port 3000.\n\n```shell\nyarn run dev\n```\n\n\n\nOnce the command has been run successfully, you should be able to view the app in localhost port 3000, or click [here](http://localhost:3000) to open the page directly.\n\n## Step2: Burning the NFT\n\nIn the app, you'll find multiple tabs, but for our code, we only need to access the`/nftBurner` page to burn the NFTs of the wallet. If you want to mint a new NFT for testing you can use the`/nftMinter`page to mint NFTs.\n\n![Nav Bar](/img/content/8fd2c8f-image.webp)\n\nTo use the app, we must first connect to the Solana wallet. This can be done by clicking the \"Select Wallet\" button on the top right. You can then connect to the wallet of your choice. \n\n![Select Wallet Button](/img/content/5e9b822-image.webp)\n\nThe code related to authentication can be found in the `src/components/modules/ConnectButton` folder, although we won't be looking at the authentication code in this tutorial. \n\nIf you want to know how authentication works, you can take a look at this [video](https://www.youtube.com/watch?v=0fuevxebv_E). You can also check out this [tutorial](/web3-data-api/solana/how-to-get-native-solana-balance-by-wallet) to learn how to get all NFTs linked to a Solana wallet. \n\nOnce the wallet connection is successful, visit the`/nftBurner` page, and we can view the NFTs the wallet is holding. \n\nThe first step of the app is to connect the Metaplex SDK with the wallet and the devnet cluster.\n\n> Only partical code is shown here to keep it clean. Visit  `src/components/templates/nftBurner` to view the entire code.\n\n```typescript NFTMinter.tsx\n/* \n* We use the connected wallet and the cluster connection\n* with metaplex for creating and processing the transactions.\n*/\nconst wallet = useWallet();\nconst connection = new Connection(clusterApiUrl('devnet'));\nconst metaplex = new Metaplex(connection);\nmetaplex.use(walletAdapterIdentity(wallet));\n```\n\n\n\nThe next step is to handle the NFTs selected by the user in the UI and then burn the NFTs. \n\nHere is the code responsible for selecting the NFTs in UI.\n\n```typescript NFTBurner.tsx\n// Refer full code in `src/components/templates/nftBurner/NFTBurner.tsx`\n\n//The NFTs selected in the UI are stored in state variable.\nconst [nftsToDelete, setNftsToDelete] = useState<Array<string>>([]);\nconst handleCheckbox = (e: ChangeEvent<HTMLInputElement>) => {\n    const { value, checked } = e.target\n    if (!nftsToDelete?.includes(value) && checked) {\n    setNftsToDelete((existing: Array<string>) => [...existing, value]);\n    } else {\n    const temp = nftsToDelete;\n    if (temp.includes(value)) {\n      temp.splice(temp.indexOf(value), 1);\n      setNftsToDelete(() => [...temp]);\n    }\n  }\n};\n\n// Component responsible for selecting NFTs in the UI\n<StyledCheckBox\n\tonChange={handleCheckbox}\n\tvalue={`${balance.mint}`}\n\ttype={'checkbox'}\n\tchecked={nftsToDelete.includes(`${balance.mint}`)}\n/>\n\n```\n\n\n\nHere is the code responsible for burning the selected NFTs.\n\n```typescript NFTBurner.tsx\n// Refer full code can be found in `src/components/templates/nftBurner/NFTBurner.tsx`\n\n// The data stored in nftsToDelete state variable is used to\n// delete the selected NFTs\n\nconst burnNFT = async () => {\n  // ...\n  const totalTxs = await Promise.all(\n    nftsToDelete.map(async (nft) => {\n      const tx = await metaplex\n        .nfts()\n        .delete({\n          mintAddress: new PublicKey(nft),\n        })\n        .run();\n      return tx;\n    }),\n  );\n  setNftsToDelete(() => []);\n  //...\n};\n```\n\n\n\nAnd there we have it! That's all the code we need to burn and delete NFTs from your wallet. \n\n## Step3: Testing\n\nThe dapp can be tested by visiting the `/NFTBurner` page. \n\nFirst, select the NFTs to delete in the UI.\n\n![NFT Selection](/img/content/9caeb78-image.webp)\n\nThen click on the \"Burn\" button to initiate the transaction and you will get a request from your wallet to sign the transaction. If you observe the gas fee in the transaction, you can see that it says `+0.0105 SOL`, which means that this transaction will return `+0.0105 SOL` back to your wallet.\n\n![Transaction View](/img/content/c9948e2-image.webp)\n\nOnce the transaction is successful, your NFT will be successfully deleted from the Solana blockchain and you will find `+0.0105 SOL` added to your wallet.\n\nCongratulations!  \n\nNow you know how to create your very own NFT burner dapp to delete spam or unwanted NFTs from the blockchain.\n\n## Support\n\nIf you have any trouble following the tutorial, feel free to reach out to our community engineers in our [Discord](https://moralis.io/discord) or [Forum](https://forum.moralis.io) to get 24/7 developer support.",
    "data": {
      "title": "Solana NFT Burner",
      "slug": "/guides/solana-nft-burner",
      "description": "This tutorial teaches you how to create your very own NFT burner dapp in NextJS using Metaplex JS SDK, and the Moralis API.",
      "tags": ["Solana API", "NFT API", "Demos"]
    },
    "isEmpty": false,
    "excerpt": ""
  },
  {
    "content": "## Introduction\n\nSolana NFT Explorer is an app powered by the Solana NFT API which lets you explore all the NFTs that any wallet is holding.\n\nIn this app we use [get Wallet NFTs](/web3-data-api/solana/how-to-get-native-solana-balance-by-wallet) endpoint, to fetch all the NFTs of a wallet and we use [get NFT Metadata](/web3-data-api/solana/how-to-get-spl-nft-metadata) endpoint to get the metadata of the wallet NFTs.\n\nThis is what the final application looks like. \n\n![Final App UI](/img/content/e976274-image.webp)\n\nThis application has the following features:\n\n- Search bar to search for NFTs in any wallet\n- Paginated results\n- Option to filter NFTs based on the NFT symbol\n\nThis tutorial will walk you through the code on how to create a similar application with the above-mentioned features.\n\nYou can find the repository with the final code here: [Solana-NFT-Explorer](https://github.com/JohnVersus/solana-nft-explorer).\n\n## Step1: Project Setup\n\nFollow these steps to run the project in your local environment.\n\n- Clone the project from [GitHub](https://github.com/JohnVersus/solana-nft-explorer) using the `git clone` command and `cd` into the project\n\n```shell\ngit clone https://github.com/JohnVersus/solana-nft-explorer.git\n\ncd solana-nft-explorer\n```\n\n\n\n- Install the dependencies using the `yarn` or `npm` package manager.\n\n```shell\nyarn install\n```\n\n\n\n- Rename `.env.local.example` file to `.env.local` and add the required environment secrets.\n\n```shell .env.local\n# Required - get from https://admin.moralis.io/web3apis\nMORALIS_API_KEY= xxx\n```\n\n\n\n- Start the app in localhost port 3000.\n\n```shell\nyarn run dev\n```\n\n\n\nOnce the command has been run successfully, you should be able to view the app in localhost port 3000, or click [here](http://localhost:3000) to open the page directly.\n\n## Step2: Fetching the NFTs\n\nThe first step when you visit the app is to search for wallet NFTs using the search bar. Clicking on the \"Search\" button uses the Solana API to fetch the NFTs.\n\n![Search Bar](/img/content/5312cd7-image.webp)\n\nHere is the code responsible for it.\n\n> Only partial code is shown here to keep it clean. Visit `pages/index.jsx` to view the entire code.\n\n:::info Instruction\n\nRead the comments in the below code in numbered order.\n\n:::\n\n```typescript index.jsx\n// Refer full code in `pages/index.jsx`\n\n// State variable to store the search input and the search result.\nconst [searchInput, setSearchInput] = useState('');\nconst [searchResult, setSearchResult] = useState([]);\n\n// 2\n// `inputHandler` function handles the address entered in search bar\n// and stores in state variable.\nconst inputHandler = (e) => {\n  const Text = e.target.value;\n  setSearchInput(Text);\n};\n\n// 4\n// `nftSearch` function will be called with a search button click.\n// This function uses the state value in `setSearchInput` and \n// calls the backend api route to fetch the NFTs using `getNFTs` api endpoint.\nconst nftSearch = async () => {\n  setSearchResult(() => null);\n  setQuery('');\n  setPage(1);\n  if (searchInput) {\n    const options = {\n      network: 'mainnet',\n      address: searchInput,\n    };\n    const response = await apiPost('/SolApi/account/getNFTs', options);\n    // 6\n    // response from backend api route is saved in the state variable\n    setSearchResult(() => response);\n  }\n};\n\nreturn (\n  //...\n  // 1\n  // Input component takes user input from search bar \n  // and triggers `inputHandler`function on input change\n  <Input \n  variant=\"filled\" \n  placeholder=\"Enter Wallet Address..\" \n  width={500} \n  onInput={inputHandler} />\n  \n  // 3\n  //Button to call the `nftSearch` function\n  <Button colorScheme=\"gray\" onClick={nftSearch}>\n    Search\n  </Button>\n   //...\n);\n\n\n// This is the code for backend API route using which \n// we fetch the wallet NFTs in `nftSearch` function.\n\n// Refer below code in `pages/api/SolApi/account/getNFTs.js`\n\n// 5\n// This API route uses `getNFTs` function from Moralis sdk to get the NFTs and\n// send the response to frontend \nimport Moralis from 'moralis';\n\nexport default async function handler(req, res) {\n  const { address, network } = req.body;\n  await Moralis.start({ apiKey: process.env.MORALIS_API_KEY });\n\n  try {\n    const data = await Moralis.SolApi.account.getNFTs({\n      network,\n      address,\n    });\n    res.status(200).json(data);\n  } catch (error) {\n    res.status(400).json(error);\n  }\n}\n\n```\n\n\n\nWith the above code, we have fetched all the NFTs of a Solana wallet and stored the NFT data in a `searchResult` state variable.\n\nNow we will use this data to fetch metadata of the NFT and update the UI with it. Here is the code for it.\n\n```typescript index.jsx\n// Refer full code in `pages/index.jsx`\n\n// The data stored in nftsToDelete state variable is used to\n// delete the selected NFTs\nconst [pageResult, setPageResult] = useState([]);\n\n// 2\n// Load pages function updates the `pageResult` state variable with \n// the first 10 items of the `searchResult` data.\n// This is because we only want to show 10 NFTs per page.\nconst loadPage = () => {\n  setPageResult(searchResult?.slice((page - 1) * 10, page * 10));\n};\n\n// 1\n// When the `searchResult` state is updated with the data from getNFTs endpoint,\n// this useEffect will be triggered and it invokes the `loadPage` function.\nuseEffect(() => {\n  loadPage();\n}, [searchResult, page]);\n\n\n\nreturn (\n  //...\n  // 3\n  // Whenever the `pageResult` state is updated this part of the UI is\n  // re-rendered with the NFT data from the `pageResult`.\n  <VStack w={'full'} h={'650'} scrollBehavior={'auto'} borderWidth={'thin'} boxShadow={'inherit'} padding={'1'}>\n    {pageResult?.length > 0 ? (\n      <Grid templateColumns=\"repeat(5, 1fr)\" gap={6} overflow=\"auto\">\n        {pageResult?.map((e, i) => {\n          // 4 \n          // `NFTCard` component is responsible for fetching the NFT metadata.\n          // Refer next step for more details.\n          return <NFTCard key={i} nftAddress={e.mint} filterQuery={query} />;\n        })}\n      </Grid>\n    ) : (\n      <Center height={500} color=\"GrayText\">\n        <i>No Data</i>\n      </Center>\n    )}\n  </VStack>\n\n  //...\n);\n\n```\n\n\n\nHere is the code of the `NFTCard` component.\n\n```typescript NFTCard.jsx\n// Refer full code in `src/components/modules/NFTCard/NFTCard.jsx`\n\n// 5\n// NFTCard uses two parameters. \n// Lets take a look at `nftAddress` address now.\nconst NFTCard = ({ nftAddress, filterQuery }) => {\n  //...\n  const [nftData, setNftData] = useState({ contractType: '', name: '', symbol: '', metadata: '' });\n  const [filterSymbol, setFilterSymbol] = useState();\n\n  //7\n  // `getNFTMetadata` function sends a request to backend api route \n  // to fetch the metadata.\n  const getNFTMetadata = async () => {\n    const options = {\n      network: 'mainnet',\n      address: nftAddress,\n    };\n    const response = await apiPost('/SolApi/nft/getNFTMetadata', options);\n    const result = await axios.get(`${response.metaplex.metadataUri}`, {\n      headers: {\n        'content-type': 'application/json',\n      },\n    });\n    setFilterSymbol(response.symbol);\n    // 9\n    // Data from backend API route is saved in `nftData` state variable.\n    setNftData({\n      contractType: response.standard,\n      name: response.name,\n      symbol: response.symbol,\n      metadata: result.data,\n    });\n  };\n\n  // 6\n  // When the component is first loaded with `nftAddress` this below\n  // useEffect will be triggered and it invokes the `getNFTMetadata` function.\n  useEffect(() => {\n    if (nftAddress) {\n      getNFTMetadata();\n    }\n  }, [nftAddress]);\n\n  if (filterSymbol?.toLowerCase().includes(filterQuery)) {\n    return (\n      <>\n      // \n      // When the data in `nftData` state variable is updated, the UI \n      // will be rendered with the NFT metadata.\n        <Box bgColor={bgColor} padding={3} borderRadius=\"xl\" borderWidth=\"1px\" borderColor={borderColor}>\n          <Box maxHeight=\"260px\" overflow={'hidden'} borderRadius=\"xl\">\n            <Image\n              src={resolveIPFS(nftData?.metadata?.image)}\n              //...\n            />\n          </Box>\n          <Box mt=\"1\" fontWeight=\"semibold\" as=\"h4\" noOfLines={1} marginTop={2}>\n            {nftData?.name ? nftData?.name : <>no name</>}\n          </Box>\n          <HStack alignItems={'center'}>\n            <Box as=\"h4\" noOfLines={1} fontWeight=\"medium\" fontSize=\"smaller\">\n              {nftData?.contractType} standard\n            </Box>\n          </HStack>\n          <SimpleGrid columns={1} spacing={4} bgColor={descBgColor} padding={2.5} borderRadius=\"xl\" marginTop={2}>\n            <Box>\n              <Box as=\"h4\" noOfLines={1} fontWeight=\"medium\" fontSize=\"sm\">\n                Symbol\n              </Box>\n              <Box as=\"h4\" noOfLines={1} fontSize=\"sm\">\n                {nftData?.symbol ? nftData?.symbol : <>no symbol</>}\n              </Box>\n            </Box>\n          </SimpleGrid>\n        </Box>\n      </>\n    );\n  }\n  return null;\n};\n```\n\n\n\nCode of backend API route to fetch NFT metadata\n\n```typescript getNFTMetadata.js\n// Refer full code in `pages/api/SolApi/nft/getNFTMetadata.js`\n\n// 8\n// This API route uses `getNFTMetadata` function from Moralis sdk to get the\n// NFT metadata and sends the response to frontend \nimport Moralis from 'moralis';\n\nexport default async function handler(req, res) {\n  const { address, network } = req.body;\n  await Moralis.start({ apiKey: process.env.MORALIS_API_KEY });\n\n  try {\n    const data = await Moralis.SolApi.nft.getNFTMetadata({\n      network,\n      address,\n    });\n    res.status(200).json(data);\n  } catch (error) {\n    res.status(400).json(error);\n  }\n}\n\n```\n\n\n\nBy now we have gone through the code responsible to fetch the NFTs and updating the NFTs in UI. \n\n## Step3: Paginated and Filtered Results\n\nLet's look at the code responsible for paginated results. \n\nNavigation between pages is handled using these buttons. \n\n![Page Navigation](/img/content/9238099-image.webp)\n\nHere is the code for it.\n\n```typescript index.jsx\n// Refer full code in `pages/index.jsx`\n\n// State variable to store the page result and page number data.\nconst [pageResult, setPageResult] = useState([]);\nconst [page, setPage] = useState(1);\n\nconst prevPage = () => {\n  setPageResult([]);\n  if (page !== 1) {\n    setPage(page - 1);\n  }\n};\n\n// 2\n// Next page function updates the page state with next page number.\nconst nextPage = () => {\n  setPageResult([]);\n  if (page < Math.ceil(searchResult.length / 10)) {\n    setPage(page + 1);\n  }\n};\n\n// 4\n// loadPage function updates the data in page result state with next 10 NFT data.\nconst loadPage = () => {\n  setPageResult(searchResult?.slice((page - 1) * 10, page * 10));\n};\n\n// 3\n// Change in page number triggers the useState and invokes the `loadPage` function\nuseEffect(() => {\n  loadPage();\n}, [searchResult, page]);\n\nreturn (\n  //...\n  // 6\n  // The same process is repeated when we click on the previous page button.\n    <Button colorScheme=\"teal\" variant=\"ghost\" onClick={prevPage} disabled={page === 1}>\n      <ArrowLeftIcon />\n    </Button>\n    <Input\n      textAlign={'right'}\n      placeholder={page}\n      htmlSize={2}\n      width=\"auto\"\n      onInput={pageInputHandler}\n      variant=\"flushed\"\n      value={page}\n    />\n    /{searchResult && Math.ceil(searchResult.length / 10)}\n    // 1\n    // Clicking on the next page button calls the `nextPage` function\n    <Button\n      colorScheme=\"teal\"\n      variant=\"ghost\"\n      onClick={nextPage}\n      disabled={page >= Math.ceil(searchResult.length / 10)}\n    >\n      <ArrowRightIcon />\n    </Button>\n  //...\n\n  //...\n  // 5\n  // Whenever the `pageResult` state is update this part of the UI is\n  // re-rendered with the NFT data from the `pageResult`.\n  <VStack w={'full'} h={'650'} scrollBehavior={'auto'} borderWidth={'thin'} boxShadow={'inherit'} padding={'1'}>\n    {pageResult?.length > 0 ? (\n      <Grid templateColumns=\"repeat(5, 1fr)\" gap={6} overflow=\"auto\">\n        {pageResult?.map((e, i) => {\n          return <NFTCard key={i} nftAddress={e.mint} filterQuery={query} />;\n        })}\n      </Grid>\n    ) : (\n      <Center height={500} color=\"GrayText\">\n        <i>No Data</i>\n      </Center>\n    )}\n  </VStack>\n\n  //...\n);\n```\n\n\n\nNow let's take a look at the filtering process.\n\nNFTs can be filtered using the search button on the top right. \n\n![Filter Input](/img/content/d2949f8-image.webp)\n\nHere is the code responsible for filtering the NFTs in UI.\n\n```typescript index.jsx\n// Refer full code in `pages/index.jsx`\n\n// State variable to store the filter query entered in the UI \nconst [query, setQuery] = useState('');\n\n// 2\n// `queryHandler` function updated the `query` state variable with the input data.\nconst queryHandler = (e) => {\n  const Text = e.target.value.toLowerCase();\n  setQuery(Text);\n};\n\nreturn (\n  //...\n  // 1\n  // Input component to enter the filter query and it triggers \n  // `queryHandler` function on input change\n    <Input variant=\"filled\" placeholder=\"Filter..\" width={200} onInput={queryHandler} />\n  //...\n\n  //...\n  // 3\n  // NFTCard Component uses the query stae as on of its property.\n  <NFTCard key={i} nftAddress={e.mint} filterQuery={query} />;\n  \n  //...\n);\n```\n\n\n\n```typescript NFTCard.jsx\n// Refer full code in `src/components/modules/NFTCard/NFTCard.jsx`\n\n// 4\n// `NFTCard` uses the `filterQuery` data when it is available\nconst NFTCard = ({ nftAddress, filterQuery }) => {\n//...\n\n// Stores the filter symbol state.\nconst [filterSymbol, setFilterSymbol] = useState(); \n  \nconst getNFTMetadata = async () => {\n  // ...\n  // 5 \n  // When metadata is fetched from the backend we store the NFT symbol\n  // in a state variable called `filterSymbol`\n setFilterSymbol(response.symbol);\n  // ...\n}\n\n // 6\n // The value of `filterSymbol` is compared with the `filterQuery` and \n // if the value matches then the NFTCard component will be rendered, \n // else the NFTCard is not rendered in the UI.\nif (filterSymbol?.toLowerCase().includes(filterQuery)) {\n return (\n  //...\n );\n}\n  return null;\n}\n\n```\n\n\n\nHere is what the filter results in the app look like.\n\n![Filtered Images](/img/content/0c56bcf-image.webp)\n\nCongratulations!  \n\nYou have successfully completed the tutorial and now you know how to create your very own NFT Explorer app. \n\n## Support\n\nIf you have any trouble following the tutorial, feel free to reach out to our community engineers in our [Discord](https://moralis.io/discord) or [Forum](https://forum.moralis.io) to get 24/7 developer support.\n",
    "data": {
      "title": "Solana NFT Explorer",
      "slug": "/guides/solana-nft-explorer",
      "description": "Solana NFT Explorer is an app powered by the Solana NFT API which lets you explore all the NFTs that any wallet is holding.",
      "tags": ["Solana API", "NFT API", "Demos"]
    },
    "isEmpty": false,
    "excerpt": ""
  },
  {
    "content": "## Introduction\n\nThis tutorial teaches you how to create your very own NFT minter dapp in NextJS using Metaplex JavaScript SDK, and the Moralis API.\n\nOnce complete, you can use this dapp to mint NFTs on the Solana blockchain in a few clicks. \n\nWe will use [Metaplex JavaScript SDK](https://github.com/metaplex-foundation/js) and the [Moralis API](/web3-data-api/solana/how-to-get-native-solana-balance-by-wallet) to mint and view the NFTs.\n\nThis is what the final application looks like. \n\n![Solana NFT Minter Page View](/img/content/5863afd-image.webp)\n\nInstead of going through the entire code, we will focus on the important sections of code that power the application. \n\nYou can find the repository with the final code here: [Solana-NFT-Minter](https://github.com/JohnVersus/solana-nft-minter).\n\n## Step1: Project Setup\n\nFollow these steps to run the project in your local environment.\n\n- Clone the project from [GitHub](https://github.com/JohnVersus/solana-nft-minter) using the `git clone` command and `cd` into the project\n\n```shell\ngit clone https://github.com/JohnVersus/solana-nft-minter.git\n\ncd solana-nft-minter\n```\n\n\n\n- Install the dependencies using the `yarn` or `npm` package manager.\n\n```shell\nyarn install\n```\n\n\n\n- Rename `.env.local.example` file to `.env.local` and add the required environment secrets.\n\n```shell .env.local\n# devent is used for chain Id as we will be testing the app on devnet chain\nAPP_CHAIN_ID=devnet\nAPP_DOMAIN=ethereum.boilerplate \n\n# Get your KEY https://admin.moralis.io/web3api\nMORALIS_API_KEY= xxx\n\n# Linux: `openssl rand -hex 32` or go to https://generate-secret.now.sh/64\nNEXTAUTH_SECRET= xxx\n\n# Replace for production\nNEXTAUTH_URL=http://localhost:3000\n\n# Wallet private used to upload NFT metadata to arweave storage\nPRIVATE_KEY = xxx\n```\n\n\n\n- Start the app in localhost port 3000.\n\n```shell\nyarn run dev\n```\n\n\n\nOnce the command has been run successfully, you should be able to view the app in localhost port 3000, or click [here](http://localhost:3000) to open the page directly.\n\n## Step2: Uploading and Minting NFT\n\nIn the app, you can find multiple tabs, but for our code, we only need to access the`/balances/nft` page to check the NFTs of the wallet, and the`/nftMinter`page to mint NFTs.\n\n![Nav Bar](/img/content/8d845e2-image.webp)\n\nTo use the app, we must first connect to the Solana wallet. This can be done by clicking the \"Select Wallet\" button on the top right. You can then connect to the wallet of your choice. \n\n![](/img/content/5e9b822-image.webp)\n\n\n\nOnce the wallet connection is successful, visit the`/balances/nft` page, and we can view the NFTs the wallet is holding. \n\nThe code related to authentication can be found in the `src/components/modules/ConnectButton` folder, although we won't be looking at the authentication code in this tutorial. \n\nIf you want to know how authentication works, you can take a look at this [video](https://www.youtube.com/watch?v=0fuevxebv_E). You can also check out this [tutorial](/web3-data-api/solana/how-to-get-native-solana-balance-by-wallet) to learn how to get all NFTs linked to a Solana wallet. \n\nThe first step of the app is to connect the Metaplex SDK with the wallet and the devnet cluster.\n\n> Only partial code is shown here to keep it clean. Visit  `src/components/templates/nftMinter` to view the entire code.\n\n```typescript NFTMinter.tsx\n/* \n* We use the connected wallet and the cluster connection\n* with metaplex for creating and processing the transactions.\n*/\nconst wallet = useWallet();\nconst connection = new Connection(clusterApiUrl('devnet'));\nconst metaplex = new Metaplex(connection);\nmetaplex.use(walletAdapterIdentity(wallet));\n```\n\n\n\nThe next step is to process the inputs which are entered by the user and upload them to decentralized storage like Arweave, IPFS, etc. In this tutorial, we will use Arweave as our storage solution, as it works seamlessly with the Metaplex SDK.  \n\nThis is the code to process the image and send the data to the backend for uploading.\n\n```typescript NFTMinter.tsx\n// full code in `src/components/templates/nftMinter/NFTMinter.tsx`\n\n//Function to process image to base64\nconst convertBase64 = (inputFile: any) => {\n  return new Promise((resolve, reject) => {\n    const fileReader = new FileReader();\n    fileReader.readAsDataURL(inputFile);\n    fileReader.onload = () => {\n      resolve(fileReader.result);\n    };\n    fileReader.onerror = (error) => {\n      reject(error);\n    };\n  });\n};\n\n// NFT metadata\nconst base64Data = await convertBase64(file[0]);\nconst options = {\n  name,\n  description,\n  image: base64Data,\n  symbol: \"M-NFT\",\n};\n\n// Sending the metdata to the backend NextJs API route for uploading to arweave\nconst uri = await apiPost(\"/upload\", options)\n  .then((data: UploadMetadataOutput) => {\n    console.log(data);\n    return data.uri;\n  })\n  .catch((e) => {\n    console.log(e);\n  });\n\n```\n\n\n\nHere's the code to upload the metadata to Arweave.\n\n```typescript upload.ts\n// Complete code can be found in `pages/api/upload.ts`\n\nexport default async function handler(req: NextApiRequest, res: NextApiResponse) {\n// Creating a new connection the backend\nconst connection = new Connection(clusterApiUrl(\"devnet\"));\nconst metaplex = new Metaplex(connection);\n\n// Using private key in backend to sign the transaction for uploading the metadata.\nconst key = Uint8Array.from(base58.decode(process.env.PRIVATE_KEY));\nconst keypair = Keypair.fromSecretKey(key);\n\n// Using bundlr storage for connecting to arweave storage\nmetaplex.use(walletAdapterIdentity(keypair));\nmetaplex.use(\n  bundlrStorage({\n    address: \"https://devnet.bundlr.network\",\n    providerUrl: \"https://api.devnet.solana.com\",\n    timeout: 60000,\n    identity: keypair,\n  })\n);\n\n// Uploading metadata\nconst data = await metaplex\n  .nfts()\n  .uploadMetadata({ name, description, image, symbol })\n  .run();\n  \n// Send the response to frontend\nres.status(200).json(data);\n}\n\n```\n\n\n\nNow let's take a look at the last step - how to mint the NFT. \n\nHere is the code:\n\n```typescript NFTMinter.tsx\n// The data which we get from backend, after uploading, contains the URI of\n// the metdata that was uploaded. \n// We use it mint the NFT on blockchain.\n\nconst data = await metaplex\n  .nfts()\n  .create({\n    uri,\n    name,\n    sellerFeeBasisPoints: 500, // represents the royality fee for the NFT\n  })\n  .run();\n\n```\n\n\n\nAnd there we have it! That's all the code we need to upload metadata to Arweave and mint an NFT on the Solana blockchain. \n\n## Step3: Testing\n\nThe dapp can be tested by visiting the `/nftMinter` page. \n\nFirst, add the required data to the form, then click on the `Mint` button to mint the NFT. \n\n![Solana NFT Minter Form](/img/content/bc24085-image.webp)\n\nThe process will take a couple of seconds, and you will be asked to sign a transaction to mint the NFT. Once the transaction is signed and confirmed, you will get a notification that the minting is successful.  \n\nYou can also visit the`/balances/nft` page to view your newly minted NFT. \n\n![NFT balance](/img/content/64db1da-image.webp)\n\nCongratulations!!  \n\nNow you know how to create your very own NFT minter dapp on the Solana blockchain.\n\n## Support\n\nIf you have any trouble following the tutorial, feel free to reach out to our community engineers in our [Discord](https://moralis.io/discord) or [Forum](https://forum.moralis.io) to get 24/7 developer support.\n",
    "data": {
      "title": "Solana NFT Minter",
      "slug": "/guides/solana-nft-minter",
      "description": "This tutorial teaches you how to create your very own NFT minter dapp in NextJS using Metaplex JavaScript SDK, and the Moralis API.",
      "tags": ["Solana API", "NFT API", "Demos"]
    },
    "isEmpty": false,
    "excerpt": ""
  },
  {
    "content": "\n## What is an Streams API?\n\n![](/img/content/d06bbe5-Moralis-Streams-API.webp)\n\nThe [Streams API](https://moralis.io/streams/) is a collection of APIs that can be used to setup Streams for listening to real-time events from contracts, native transactions, and internal transactions on multiple [EVM chains](/streams-api/evm#supported-chains) that we support.\n\nThe [Streams API](https://moralis.io/streams/) is designed to stream real-time blockchain data to application through webhooks that help developers to improves the user experience.\n\nTherefore, the ideal use cases for the [Streams API](https://moralis.io/streams/) are listed as below, but not limited to:\n\n- Web3 alerts (e.g. whale alerts monitoring)\n- Real-time transaction & crypto wallet notifications\n- Monitoring wallet balances\n- etc.\n\n## How to get started?\n\nTo get started with [Moralis Streams API](https://moralis.io/streams/), there are two methods that can be used to create [Streams](https://moralis.io/streams/), depending on the programming language that you are using:\n\n| Programming Languages                 | Method       |\n| ------------------------------------- | ------------ |\n| JavaScript/TypeScript, Python         | Moralis SDKs |\n| Others (e.g. Java, C/C++, Ruby, etc.) | REST API     |\n\nFor this guide, we'll particularly use the Moralis SDK for examples.\n\nIf you would like to use other languages calling the [Moralis Streams API](https://moralis.io/streams/) using regular REST API call, then make sure to check the [Streams API reference pages](/streams-api/evm/reference/get-history) to get all the parameters and responses type.\n\nIn production, you should have your own webhook setup, but for the scope of this tutorial, we will be using [https://webhook.site](https://webhook.site) to get your test webhook. To get your test webhook, simply go to the site and copy the given unique URL.\n\n### Step 1: Install Moralis SDK\n\nimport SetupMoralis from '/docs/partials/\\_install-moralis-sdk.mdx';\n\n<SetupMoralis node=\"moralis\" python=\"moralis\" />\n\n### Step 2: Monitor On-Chain Wallet Transactions\n\nOnce you have [your API key](/web3-data-api/evm/get-your-api-key) and [webhook URL](https://webhook.site), let's set up our first stream to monitor on-chain crypto wallet transactions. In this instance, let's monitor the `0x68b3f12d6e8d85a8d3dbbc15bba9dc5103b888a4` address.\n\nTo do so, copy the following code:\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n<Tabs groupId=\"programming-language\">\n  <TabItem value=\"javascript\" label=\"JavaScript\" default>\n\n```javascript index.js\nconst Moralis = require(\"moralis\").default;\nconst { EvmChain } = require(\"@moralisweb3/common-evm-utils\");\n\nconst runApp = async () => {\n  await Moralis.start({\n    apiKey: \"YOUR_API_KEY\",\n  });\n\n  const stream = {\n    chains: [EvmChain.ETHEREUM, EvmChain.POLYGON],\n    description: \"monitor Bobs wallet\",\n    tag: \"bob\",\n    webhookUrl: \"https://YOUR_WEBHOOK_URL\",\n    includeNativeTxs: true,\n  };\n\n  const newStream = await Moralis.Streams.add(stream);\n  const { id } = newStream.toJSON();\n\n  // Now we attach bobs address to the stream\n  const address = \"0x68b3f12d6e8d85a8d3dbbc15bba9dc5103b888a4\";\n\n  await Moralis.Streams.addAddress({ address, id });\n};\n\nrunApp();\n```\n\n</TabItem>\n<TabItem value=\"typescript\" label=\"TypeScript\">\n\n```typescript index.ts\nimport Moralis from \"moralis\";\nimport { EvmChain } from \"@moralisweb3/common-evm-utils\";\n\nconst runApp = async () => {\n  await Moralis.start({\n    apiKey: \"YOUR_API_KEY\",\n  });\n\n  const stream = {\n    chains: [EvmChain.ETHEREUM, EvmChain.POLYGON],\n    description: \"monitor Bobs wallet\",\n    tag: \"bob\",\n    webhookUrl: \"https://YOUR_WEBHOOK_URL\",\n    includeNativeTxs: true,\n  };\n\n  const newStream = await Moralis.Streams.add(stream);\n  const { id } = newStream.toJSON();\n\n  // Now we attach bobs address to the stream\n  const address = \"0x68b3f12d6e8d85a8d3dbbc15bba9dc5103b888a4\";\n\n  await Moralis.Streams.addAddress({ address, id });\n};\n\nrunApp();\n```\n\n</TabItem>\n<TabItem value=\"python\" label=\"Python\">\n\n```python index.py\nfrom moralis import streams\n\napi_key = \"04u5XkBCRyoxrAM89MeOSV055R6QpRxTWGw431jWd8ydCJtq0TpY6jErerZ9FN3u\"\n\ncreate_stream_body = {\n  \"description\": \"monitor Bobs wallet\",\n  \"tag\": \"bob\",\n  \"webhook_url\": \"https://YOUR_WEBHOOK_URL\",\n  \"include_native_txs\": True,\n  \"chain_ids\": [\n    \"0x1\",\n    \"0x89\"\n  ]\n}\n\nresult = streams.evm_streams.create_stream(\n  api_key=api_key,\n  body=create_stream_body,\n)\n\nadd_address_body = {\n  \"address\": \"0x68b3f12d6e8d85a8d3dbbc15bba9dc5103b888a4\"\n}\n\nparams = {\n  \"id\": result.id\n}\n\n# Now we attach bobs address to the stream\nstreams.evm_streams.add_address_to_stream(\n  api_key=api_key,\n  body=add_address_body,\n  params=params,\n)\n```\n\n</TabItem>\n</Tabs>\n\nOnce the code has been added, you can run the script to create the [Streams](https://moralis.io/streams/). This will be reflected on your Moralis Dashboard as well. From here, you shall receive new real-time responses on your attached webhook for any new transactions occuring on either Ethereum or Polygon.\n\n### Step 3: Listen to Smart Contract Events\n\nOther than monitoring crypto wallet transactions in real-time, you can also use [Streams](https://moralis.io/streams/) to listen to real-time smart contract events whenever it is emitted on the particular blockchain you are listening to.\n\nSuppose we'd like to listen to all ERC20 transfers for a [USDT](https://etherscan.io/token/0xdac17f958d2ee523a2206206994597c13d831ec7). Then, the streams setup shall be as follows:\n\n<Tabs groupId=\"programming-language\">\n  <TabItem value=\"javascript\" label=\"JavaScript\" default>\n\n```javascript index.js\nconst Moralis = require(\"moralis\").default;\nconst { EvmChain } = require(\"@moralisweb3/common-evm-utils\");\n\nconst ERC20_transfer_ABI = [\n  {\n    anonymous: false,\n    inputs: [\n      { indexed: true, name: \"from\", type: \"address\" },\n      { indexed: true, name: \"to\", type: \"address\" },\n      { indexed: false, name: \"value\", type: \"uint256\" },\n    ],\n    name: \"Transfer\",\n    type: \"event\",\n  },\n];\n\nconst runApp = async () => {\n  await Moralis.start({\n    apiKey: \"YOUR_API_KEY\",\n  });\n\n  const stream = {\n    chains: [EvmChain.ETHEREUM],\n    description: \"monitor USDT transfers\",\n    tag: \"USDT\",\n    webhookUrl: \"https://YOUR_WEBHOOK_URL\",\n    abi: ERC20_transfer_ABI,\n    includeContractLogs: true,\n    topic0: [\"Transfer(address,address,uint256)\"],\n  };\n\n  const newStream = await Moralis.Streams.add(stream);\n  const { id } = newStream.toJSON();\n\n  // Now we attach USDT address to the stream\n  const address = \"0xdAC17F958D2ee523a2206206994597C13D831ec7\";\n\n  await Moralis.Streams.addAddress({ address, id });\n};\n\nrunApp();\n```\n\n</TabItem>\n<TabItem value=\"typescript\" label=\"TypeScript\">\n\n```typescript index.ts\nimport Moralis from \"moralis\";\nimport { EvmChain } from \"@moralisweb3/common-evm-utils\";\n\nconst ERC20_transfer_ABI = [\n  {\n    anonymous: false,\n    inputs: [\n      { indexed: true, name: \"from\", type: \"address\" },\n      { indexed: true, name: \"to\", type: \"address\" },\n      { indexed: false, name: \"value\", type: \"uint256\" },\n    ],\n    name: \"Transfer\",\n    type: \"event\",\n  },\n];\n\nconst runApp = async () => {\n  await Moralis.start({\n    apiKey: \"YOUR_API_KEY\",\n  });\n\n  const stream = {\n    chains: [EvmChain.ETHEREUM],\n    description: \"monitor USDT transfers\",\n    tag: \"USDT\",\n    webhookUrl: \"https://YOUR_WEBHOOK_URL\",\n    abi: ERC20_transfer_ABI,\n    includeContractLogs: true,\n    topic0: [\"Transfer(address,address,uint256)\"],\n  };\n\n  const newStream = await Moralis.Streams.add(stream);\n  const { id } = newStream.toJSON();\n\n  // Now we attach USDT address to the stream\n  const address = \"0xdAC17F958D2ee523a2206206994597C13D831ec7\";\n\n  await Moralis.Streams.addAddress({ address, id });\n};\n\nrunApp();\n```\n\n</TabItem>\n<TabItem value=\"python\" label=\"Python\">\n\n```python index.py\nfrom moralis import streams\n\napi_key = \"YOUR_API_KEY\"\n\nERC20_transfer_ABI = [{\n  \"anonymous\": false,\n  \"inputs\": [\n    { \"indexed\": true, \"name\": \"from\", \"type\": \"address\" },\n    { \"indexed\": true, \"name\": \"to\", \"type\": \"address\" },\n    { \"indexed\": false, \"name\": \"value\", \"type\": \"uint256\" },\n  ],\n  \"name\": \"Transfer\",\n  \"type\": \"event\",\n}]\n\ncreate_stream_body = {\n  \"description\": \"monitor USDT transfers\",\n  \"tag\": \"USDT\",\n  \"webhook_url\": \"https://YOUR_WEBHOOK_URL\",\n  \"include_contract_logs\": True,\n  \"chain_ids\": [\n    \"0x1\"\n  ],\n  \"abi\": ERC20_transfer_ABI,\n  \"topic0\": [\"Transfer(address,address,uint256)\"]\n}\n\nresult = streams.evm_streams.create_stream(\n  api_key=api_key,\n  body=create_stream_body,\n)\n\nadd_address_body = {\n  \"address\": \"0xdAC17F958D2ee523a2206206994597C13D831ec7\"\n}\n\nparams = {\n  \"id\": result.id\n}\n\n# Now we attach USDT address to the stream\nstreams.evm_streams.add_address_to_stream(\n  api_key=api_key,\n  body=add_address_body,\n  params=params,\n)\n```\n\n</TabItem>\n</Tabs>\n\nOnce the code has been added, you can run the script to create a second [Streams](https://moralis.io/streams/). This will be reflected on your Moralis Dashboard as well. From here, you shall receive new real-time responses on your attached webhook for any new USDT transfers occuring on either Ethereum.\n\nFor listening to smart contracts, you can also add the [Filters feature](/streams-api/evm/filter-streams) to filter out results that only fulfills certain criteria. This can be relevant in more specific use cases, such as whale monitoring, and can simply be supplemented to our existing code.\n\nFor example, we'd like to monitor all USDT transaction on Ethereum that is over $1M, then we can modify our code as follows:\n\n<Tabs groupId=\"programming-language\">\n  <TabItem value=\"javascript\" label=\"JavaScript\" default>\n\n```javascript index.js\n// Above code is same as prior\n\nconst filter_ERC20 = {\n  \"and\": \\[\n    { \"eq\": [\"from\", \"0x283af0b28c62c092c9727f1ee09c02ca627eb7f5\"] },\n    { \"gt\": [\"value\", \"1000000000\"] }, // Example of USDT (6 Decimals)\n  ],\n};\n\nconst runApp = async () => {\n  const stream = {\n    // same parameters as prior\n    advancedOptions: [\n      {\n        topic0: \"Transfer(address,address,uint256)\",\n        filter: filter_ERC20\n      },\n    ]\n  };\n\n  const newStream = await Moralis.Streams.add(stream);\n  const { id } = newStream.toJSON();\n\n  // Now we attach USDT address to the stream\n  const address = \"0xdAC17F958D2ee523a2206206994597C13D831ec7\";\n\n  await Moralis.Streams.addAddress({ address, id });\n};\n\nrunApp();\n```\n\n</TabItem>\n<TabItem value=\"typescript\" label=\"TypeScript\">\n\n```typescript index.ts\n// Above code is same as prior\n\nconst filter_ERC20 = {\n  \"and\": \\[\n    { \"eq\": [\"from\", \"0x283af0b28c62c092c9727f1ee09c02ca627eb7f5\"] },\n    { \"gt\": [\"value\", \"1000000000\"] }, // Example of USDT (6 Decimals)\n  ],\n};\n\nconst runApp = async () => {\n  const stream = {\n    // same parameters as prior\n    advancedOptions: [\n      {\n        topic0: \"Transfer(address,address,uint256)\",\n        filter: filter_ERC20\n      },\n    ]\n  };\n\n  const newStream = await Moralis.Streams.add(stream);\n  const { id } = newStream.toJSON();\n\n  // Now we attach USDT address to the stream\n  const address = \"0xdAC17F958D2ee523a2206206994597C13D831ec7\";\n\n  await Moralis.Streams.addAddress({ address, id });\n};\n\nrunApp();\n```\n\n</TabItem>\n<TabItem value=\"python\" label=\"Python\">\n\n```python index.py\n# Above code is same as prior\n\nfilter_ERC20 = {\n  \"and\": \\[\n    { \"eq\": [\"from\", \"0x283af0b28c62c092c9727f1ee09c02ca627eb7f5\"] },\n    { \"gt\": [\"value\", \"1000000000\"] }, // Example of USDT (6 Decimals)\n  ],\n}\n\ncreate_stream_body = {\n  # same parameters as prior\n  \"advanced_options\": [\n    {\n      \"topic0\": \"Transfer(address,address,uint256)\",\n      \"filter\": filter_ERC20\n    }\n  ]\n}\n\nresult = streams.evm_streams.create_stream(\n  api_key=api_key,\n  body=create_stream_body,\n)\n\nadd_address_body = {\n  \"address\": \"0xdAC17F958D2ee523a2206206994597C13D831ec7\"\n}\n\nparams = {\n  \"id\": result.id\n}\n\n# Now we attach USDT address to the stream\nstreams.evm_streams.add_address_to_stream(\n  api_key=api_key,\n  body=add_address_body,\n  params=params,\n)\n```\n\n</TabItem>\n</Tabs>\n\nOnce modified, you will only receive all USDT transfers on Ethereum over $1M real-time on your webhooks.\n",
    "data": {
      "title": "Streams API - Full Guide & Walkthrough",
      "slug": "/guides/streams-api-full-guide-walkthrough",
      "description": "This tutorial teaches you what the Streams API is, what are some of its most common use cases, and how to use it within your tech stack.",
      "tags": ["Streams"]
    },
    "isEmpty": false,
    "excerpt": ""
  },
  {
    "content": "\n\nThis tutorial is a continuation of the previous tutorial on how to use Moralis' Auth API in Django. Now, in this tutorial, you will learn how to show content for a restricted page only when the currently authenticated user holds a specific NFT.\n\nThis is an example of the final result:\n\n![Protected Page](/img/content/1c0bae3-protected_with_nft_2.webp)\n\n## Prerequisites\n\n1. Finish the previous tutorial on how to use the [Moralis Auth API in Django](/authentication-api/evm/how-to-sign-in-with-metamask-python-django).\n\n## Adding NFT Gated Functionality\n\n1. Add a new view in `views.py` named `protected`:\n\n```python views.py\ndef protected(request):\n    eth_address = request.session.get(\n        'verified_data', {}).get('address', None)\n    nfts = []\n    # this is the opensea contract address on polygon\n    CONTRACT_ADDRESS = \"0x2953399124f0cbb46d2cbacd8a89cf0599974963\"\n    WEB3_API_URL = 'https://deep-index.moralis.io/api/v2'\n    REQUEST_URL = '%s/%s/nft?chain=polygon&token_addresses=%s' % (\n        WEB3_API_URL,\n        eth_address,\n        CONTRACT_ADDRESS\n        )\n         \n    x = requests.get(\n        REQUEST_URL,\n        headers={'X-API-KEY': API_KEY})\n    print(json.loads(x.text))\n    nfts = json.loads(x.text)['result']\n    # show only 1 nft\n    if nfts:\n        nfts = json.dumps([nfts[0]], indent=4)\n    print(eth_address)\n    print(nfts)\n    return render(\n        request, 'protected.html',\n        {'nfts': nfts})\n```\n\n\n\nIn this view, we are going to extract the address from the current user session. Then, we will make a Web3 API request to get the NFTs for the current wallet address for a specific contract address. In this particular case, we decided to go with the Polygon chain.\n\n2. Add a template named `protected.html`:\n\n```html protected.html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Moralis Django NFT Gated Demo Page</title>\n</head>\n<body>\n    <div>\n\n    {% if user.is_authenticated %}\n        <h1>Eth address: {{ user.username }}</h1>\n        <h2>Protected content</h2>\n        {% if nfts %}\n          <h3>Nice! You have our NFT!</h3>\n          <pre>\n{{ nfts }}\n          </pre>\n        {% else %}\n          <h3>Sorry, you don't have our NFT!</h3>\n        {% endif %}\n        <br/>\n        <a href=\"{% url 'logout' %}?next={% url 'moralis_auth' %}\">Logout</a>\n    {% else %}\n        <a href=\"{% url 'moralis_auth' %}\"> Login page </a>\n    {% endif %}\n    </div>\n\n</body>\n</html>\n```\n\n\n\n3. Add this line in `urls.py` for the current Django application:\n\n```python urls.py\npath('protected', views.protected, name='protected'),\n```\n\n\n\n## Final Result\n\n![Page When Wallet Address Holds An NFT From A Specific  Contract Address](/img/content/91158d8-protected_with_nft_2.webp)\n\n![Page When Wallet Address Does Not Hold NFT](/img/content/b74feb4-protected_without_nft.webp)",
    "data": {
      "title": "Token Gating Website (Django)",
      "slug": "/guides/token-gating-website-django",
      "description": "This tutorial is a continuation of the previous tutorial on how to use Moralis' Auth API in Django. Now, in this tutorial, you will learn how to show content for a restricted page only when the currently authenticated user holds a specific NFT.",
      "tags": ["Authentication API", "NFT API", "Demos"]
    },
    "isEmpty": false,
    "excerpt": ""
  },
  {
    "content": "## Introduction\n\nThis tutorial shows you how to connect an **Unreal game** to a **Moralis backend**, in this case hosted on **AWS Lambda**. We will retrieve a wallet's **native balance** and its **NFTs**.\\nBelow we provide a sample game to set everything up in a few minutes.\n\n## Prerequisites\n\n- Complete [AWS Lambda integration](/web3-data-api/evm/integrations/aws-lambda-nodejs).\n- Install [Unreal Engine 5.1 ](https://docs.unrealengine.com/5.1/en-US/installing-unreal-engine/).\n- Install [VaRest plugin](https://www.unrealengine.com/marketplace/en-US/product/varest-plugin) to Unreal Engine 5.1.\n\n## Open sample game\n\n:::info Download sample game\n\nGo to [GitHub](https://github.com/MoralisWeb3/demo-unreal-aws-lambda) and clone/download the repository.\n\n:::\n\nAfter downloading the project, launch Unreal Engine 5.1 and under _RECENT PROJECTS_, choose _**Browse**_:\n\n![](/img/content/4353feb-image.webp)\n\nSearch for the **`.uproject`** file and open it:\n\n![](/img/content/ff45723-image.webp)\n\nThe _Plugins_ window should automatically open but if not, go to the top toolbar and choose **_Edit --> Plugins_**:\n\n![](/img/content/2e240ee-image.webp)\n\nSearch for _VaRest_, **enable the checkbox** and close the _Plugins_ window:\n\n![](/img/content/e3e2255-image.webp)\n\n:::info \nAs stated in the [prerequisites](#prerequisites), you need to have this plugin previously installed. We will use it to call our **Moralis API endpoints** hosted in **AWS Lambda**.\n:::\n\n## Setting up\n\nOn the editor, click the blueprint icon and choose _**Open Level Blueprint**_:\n\n![](/img/content/d39c0e4-image.webp)\n\nThis is the blueprint holding most of the logic of this sample game.\n\nZoom out to visualize and locate **4 important areas**:\n\n- [Introduction](#introduction)\n- [Prerequisites](#prerequisites)\n- [Open sample game](#open-sample-game)\n- [Setting up](#setting-up)\n  - [Manage input](#manage-input)\n  - [Construct request body](#construct-request-body)\n  - [Get Native Balance](#get-native-balance)\n  - [Get Wallet NFTs](#get-wallet-nfts)\n  - [Saving changes](#saving-changes)\n- [Play the game](#play-the-game)\n\n![](/img/content/0d0bd99-image.webp)\n\n### Manage input\n\n:::info \nNo need to do any action here. Just informative.\n:::\n\nApart from enabling and disabling the player's input, here we get the `wallet address` and the `chain ID` from the text input fields when the _START_ button is clicked and we save them as variables:\n\n![](/img/content/d81ba07-image.webp)\n\n### Construct request body\n\n:::info \nNo need to do any action here. Just informative.\n:::\n\nWhat interests us in this tutorial is to know **how do we call an API endpoint**. In this case we want to call the _getNativeBalance_ and _getWalletNfts_ endpoints hosted in our [Express AWS Lambda App](/web3-data-api/evm/integrations/aws-lambda-nodejs#lambda-nodejs-express-api). These endpoints need the _address_ and the _chain_ as request body parameters so here we construct the request and we **set it as a variable**:\n\n![](/img/content/e9fdaae-image.webp)\n\n### Get Native Balance\n\nAdd the _getNativeBalance_ endpoint URL to the _**URL field**_. You can get it [following the instructions here](/web3-data-api/evm/integrations/aws-lambda-nodejs#testing-express-api-function):\n\n![](/img/content/4b02975-image.webp)\n\n### Get Wallet NFTs\n\nAdd the _getWalletNfts_ endpoint URL to the **_URL field_**. You can get it [following the instructions here](/web3-data-api/evm/integrations/aws-lambda-nodejs#testing-express-api-function):\n\n![](/img/content/0662f30-image.webp)\n\n### Saving changes\n\nClick _**Compile**_ and then the _**Save icon**_: \n\n![](/img/content/c03b362-image.webp)\n\n:::tip Everything is set up correctly.\n\n:::\n\n## Play the game\n\nOn the editor, choose **_Play_**:\n\n![](/img/content/64b1f25-image.webp)\n\nEnter a _wallet address_ and a _chain ID_ and choose _**START**_:\n\n![](/img/content/98ccd15-image.webp)\n\n:::info \nIn this tutorial, we enter **`80001`** as chain ID but here you can check [all the chains that Moralis supports](/web3-data-api/evm#supported-chains).\n:::\n\n:::info \nAlso make sure to enter an address that holds some NFTs to see them on the game.\n:::\n\nOn the left side we can see our **NFTs** displayed and our **Native balance** on the right side:\n\n![](/img/content/d5835b1-image.webp)\n\n:::tip Congratulations!\n\nYou've completed the **Moralis & Unreal Engine 5** integration tutorial.\n\n:::",
    "data": {
      "title": "Unreal 5 Get Web3 Data",
      "slug": "/guides/unreal-5-get-web3-data",
      "description": "This tutorial shows you how to connect an **Unreal game** to a **Moralis backend**, in this case hosted on **AWS Lambda**. We will retrieve a wallet's **native balance** and its **NFTs**.\nBelow we provide a sample game to set everything up in a few minutes.",
      "tags": ["NFT API", "Balance API", "Demos"]
    },
    "isEmpty": false,
    "excerpt": ""
  },
  {
    "content": "## Introduction\n\nThis tutorial teaches you how to create your very own decentralized social profile using [Lens](https://www.lens.xyz/) and the Moralis API.\n\nLens is a blockchain social media protocol that allows anyone to build Web3 social media apps on top of it.\n\nYou can find the repository with the [final code here](https://github.com/IAmJaysWay/lens).\n\n## YouTube Tutorial\n\nhttps://www.youtube.com/watch?v=Nn6N7IJKcgE\n\n## How to Start\n\n1. Setup a starter (Next.js) app\n2. Connect to the Lens API\n3. Import and set up the Moralis SDK\n4. Integrate your app with Moralis \n\n## Prerequisites\n\n1. Clone the [starter repo](https://github.com/IAmJaysWay/lens-starter), install it, and run the app:\n\n```shell\ngit clone https://github.com/IAmJaysWay/lens-starter\ncd lens-starter\ncd web3profile-starter\nnpm install\nnpm run dev\n```\n\n\n\n2. Open [`http://localhost:3000`](http://localhost:3000) in your browser. You should see the following:\n\n![](/img/content/8b6d8c8-Web3_Social_Media_1.webp)\n\n## Initial Setup\n\nWe will set up our connection to Lens (using their [API](https://docs.lens.xyz/docs/introduction)) from our app. We will use the `urql` library to create a GraphQL client that will be used to query this API.\n\n1. Inside `src/pages`, create a folder called `api`, and inside that folder, create a file called `lensCalls.js`. Open it and add our initial client setup code:\n\n```javascript\nimport { createClient } from 'urql';\n\nconst APIURL = 'https://api.lens.dev';\n\nexport const client = new createClient({\n  url: APIURL,\n});\n\n```\n\n\n\n2. Add our API profile code:\n\n```javascript\nexport const Profile = `\nquery Profile {\n  profile(request: { profileId: \"0x09\" }) {\n    id\n    name\n    bio\n    attributes {\n      displayType\n      traitType\n      key\n      value\n    }\n    followNftAddress\n    metadata\n    isDefault\n    picture {\n      ... on NftImage {\n        contractAddress\n        tokenId\n        uri\n        verified\n      }\n      ... on MediaSet {\n        original {\n          url\n          mimeType\n        }\n      }\n      __typename\n    }\n    handle\n    coverPicture {\n      ... on NftImage {\n        contractAddress\n        tokenId\n        uri\n        verified\n      }\n      ... on MediaSet {\n        original {\n          url\n          mimeType\n        }\n      }\n      __typename\n    }\n    ownedBy\n    dispatcher {\n      address\n      canUseRelay\n    }\n    stats {\n      totalFollowers\n      totalFollowing\n      totalPosts\n      totalComments\n      totalMirrors\n      totalPublications\n      totalCollects\n    }\n    followModule {\n      ... on FeeFollowModuleSettings {\n        type\n        amount {\n          asset {\n            symbol\n            name\n            decimals\n            address\n          }\n          value\n        }\n        recipient\n      }\n      ... on ProfileFollowModuleSettings {\n        type\n      }\n      ... on RevertFollowModuleSettings {\n        type\n      }\n    }\n  }\n}\n`\n```\n\n\n\nNow we will set up our page to call this API.\n\n3. Open `pages/index.js`. At the top, add our imports for our client and the profile code we just set up:\n\n```javascript\nimport { urqlClient, Profile } from './api/lensCalls';\n```\n\n\n\n4. We will call the Lens API with [`getServerSideProps`](https://nextjs.org/docs/basic-features/data-fetching/get-server-side-props) which will run the code server side and return the data to the `index.js` page as props:\n\n```javascript\nexport async function getServerSideProps() {\n  const response = await urqlClient.query(Profile).toPromise();\n\n  return {\n    props: { profile: response?.data.profile },\n  };\n}\n```\n\n\n\n5. We will adjust the `Home` component to receive these props and log `profile` to make sure it all works:\n\n```javascript\nexport default function Home({ profile }) {\n  console.log(profile);\n  \n  // rest of Home\n```\n\n\n\n6. Check your browser console (developer tools), you should see similar output to the following:\n\n```json\n{\n    \"id\": \"0x09\",\n    \"name\": \"Nicolo\",\n    \"bio\": \"Strategy @AaveAave.lens & @LensProtocol\\n\\nnicolo.eth\",\n    \"attributes\": [\n        {\n            \"displayType\": null,\n            \"traitType\": \"string\",\n            \"key\": \"location\",\n            \"value\": \"London, UK\",\n            \"__typename\": \"Attribute\"\n        },\n        {\n            \"displayType\": null,\n            \"traitType\": \"string\",\n            \"key\": \"twitter\",\n            \"value\": \"nicolo\",\n            \"__typename\": \"Attribute\"\n        },\n        {\n            \"displayType\": null,\n            \"traitType\": \"string\",\n            \"key\": \"statusMessage\",\n            \"value\": \"\",\n            \"__typename\": \"Attribute\"\n        },\n        {\n            \"displayType\": null,\n            \"traitType\": \"string\",\n            \"key\": \"app\",\n            \"value\": \"Lenster\",\n            \"__typename\": \"Attribute\"\n        }\n    ],\n    ...\n}\n```\n\n\n\n## Populating Our Profile Page\n\nWe now have info about this user that we will use to populate our frontend.\n\n1. In `pages/index.js`, we will swap out the default values with the properties from `profile`. The complete `return` should look like this:\n\n```javascript\nreturn (\n    <div className={styles.container}>\n      <img\n        className={styles.banner}\n        src={profile.coverPicture.original.url}\n        alt=\"cover\"\n      />\n      <div className={styles.profile}>\n        <div className={styles.profileLeft}>\n          <img\n            className={styles.profileImg}\n            src={profile.picture.original.url}\n            alt=\"profileImg\"\n          />\n          <div className={styles.info}>\n            <div className={styles.name}>{profile.name}</div>\n            <div className={styles.handle}>{profile.handle}</div>\n            <div className={styles.bio}>{profile.bio}</div>\n            <div className={styles.follow}>\n              <div>Followers</div>\n              <div>{profile.stats.totalFollowers}</div>\n            </div>\n            <div className={styles.follow}>\n              <div>Following</div>\n              <div>{profile.stats.totalFollowing}</div>\n            </div>\n          </div>\n        </div>\n        <div className={styles.profileRight}>\n          <Tabs defaultActiveKey=\"1\" centered>\n            <TabPane tab=\"I'm Following\" key=\"1\">\n              <div className={styles.followingNFTs}>\n                {nftArray?.map((e) => {\n                  return <iframe className={styles.animation} src={e}></iframe>;\n                })}\n              </div>\n            </TabPane>\n            <TabPane tab=\"Follow Me\" key=\"2\">\n              <div className={styles.followMe}>\n                <div>\n                  <div className={styles.promptOne}>Hey There </div>\n                  <div className={styles.promptTwo}>\n                    Give me a follow and receive this cool NFT!\n                  </div>\n                  <Button onClick={follow} type=\"primary\">\n                    Follow Me\n                  </Button>\n                </div>\n                {myNFT && (\n                  <iframe className={styles.myNFT} src={myNFT}></iframe>\n                )}\n              </div>\n            </TabPane>\n            <TabPane tab=\"Social Posts\" key=\"3\" disabled={true} />\n          </Tabs>\n        </div>\n      </div>\n    </div>\n  );\n```\n\n\n\n2. Check [`http://localhost:3000`](http://localhost:3000). Your app should now look similar to:\n\n![](/img/content/2927bab-Web3_Social_Media_2.webp)\n\n3. We can now change the profile ID in `pages/api/lensCalls.js` to use another profile for our app. We will use the following`0x81`:\n\n```javascript\nprofile(request: { profileId: \"0x81\" }) {\n  ...\n```\n\n\n\n4. Reload the page and it should look different:\n\n![](/img/content/f00285d-Web3_Social_Media_3.webp)\n\n## Using the Moralis API\n\nWe will now use the wallet address found in this profile (`ownedBy`) to get the Lens NFTs that they own which will display on the \"I'm Following\" tab. These NFTs represent which Lens profiles this user is following.\n\n1. Create a file named `.env.local` in the root of your project (where `package.json` is) and add the following:\n\n```Text .env.local\nMORALIS_API_KEY=replace_me\n```\n\n\n\nTo get your Moralis API key, [check out this guide](/web3-data-api/evm/get-your-api-key).\n\n2. In `pages/index.js`, add our Moralis SDK import at the top:\n\n```javascript\nimport Moralis from 'moralis';\n```\n\n\n\n3. Inside `getServerSideProps`, add the following code that will call the Moralis API, filter the results for any Lens NFTs, and return the final NFT array:\n\n```javascript\nconst balances = await Moralis.EvmApi.account.getNFTs({\n    address: response?.data.profile.ownedBy,\n    chain: 0x89,\n  });\n\n  let nftArray = [];\n  let nfts = balances?.data.result;\n\n  for (let i = 0; i < nfts.length; i++) {\n    if (nfts[i].metadata !== null) {\n      if (\n        'animation_url' in JSON.parse(nfts[i].metadata) &&\n        JSON.parse(nfts[i].metadata).animation_url !== null &&\n        JSON.parse(nfts[i].metadata).animation_url.includes('.lens')\n      ) {\n        nftArray.push(JSON.parse(nfts[i].metadata).animation_url);\n      }\n    }\n  }\n\n  return {\n    props: { profile: response?.data.profile, nftArray: nftArray },\n  };\n```\n\n\n\n4. In our `Home` component, we will now include `nftArray`:\n\n```javascript\nexport default function Home({ profile, nftArray }) {\n  console.log(profile);\n\n  // let nftArray; remove or comment this out\n  let myNFT;\n  \n  ...\n```\n\n\n\n5. Reload [`http://localhost:3000`](http://localhost:3000), you should now see the follower NFTs:\n\n![](/img/content/21ce843-Web3_Social_Media_4.webp)\n\n## Add the Profile's \"Follow\" NFT\n\nNow we will show the NFT that users would get if they followed this profile. The token address will be available in the profile data.\n\n1. Inside `getServerSideProps`, add the following:\n\n```\nconst followNFT = await Moralis.EvmApi.token.getTokenIdMetadata({\n  address: response?.data.profile.followNftAddress,\n  chain: 0x89,\n  tokenId: 1,\n});\n\nconst myNFT = JSON.parse(followNFT.data.metadata).animation_url;\n\nreturn {\n  props: {\n    profile: response?.data.profile,\n    nftArray: nftArray,\n    myNFT: myNFT,\n  },\n};\n}\n```\n\n\n\n2. In our `Home` component, we will now include `myNFT`:\n\n```javascript\nexport default function Home({ profile, nftArray, myNFT }) {\n  console.log(profile);\n\n  //let myNFT; remove or comment this out\n  \n  ...\n```\n\n\n\n3. Reload [`http://localhost:3000`](http://localhost:3000)and click on the \"Follow Me\" tab. You should now see the \"follow\" NFT:\n\n![](/img/content/58cad1f-Web3_Social_Media_5.webp)\n\n## Adding Follow Functionality\n\nThe last feature we will add is allowing users to follow this profile. The ABI we need for interacting with the Lens contract is already included in the starter project.\n\nWe will use [wagmi](https://wagmi.sh/) for wallet integration.\n\n1. In `pages/index.js`, add these imports:\n\n```javascript\nimport { useConnect, useAccount, useDisconnect, useContractWrite, usePrepareContractWrite } from 'wagmi'\nimport { MetaMaskConnector } from \"wagmi/connectors/metaMask\";\nimport abi from \"../abi.json\"; \n```\n\n\n\n2. In our `Home` component, add the hooks needed to connect our wallet (MetaMask) and make a contract call:\n\n```javascript\nexport default function Home({ profile, nftArray, myNFT }) {\n  console.log(profile);\n\n  const { connectAsync } = useConnect();\n  const { disconnectAsync } = useDisconnect();\n  const { isConnected } = useAccount();\n  const { config } = usePrepareContractWrite({\n    addressOrName: '0xDb46d1Dc155634FbC732f92E853b10B288AD5a1d',\n    contractInterface: abi,\n    functionName: 'follow',\n    args: [[profile.id], [0x0]],\n  });\n\n  const { write } = useContractWrite(config);\n  \n  ...\n```\n\n\n\n3. Replace the current `follow` function (which is called when the \"Follow Me\" button is clicked) with the following:\n\n```javascript\nasync function follow() {\n  if (isConnected) {\n    await disconnectAsync();\n  }\n  await connectAsync({\n    connector: new MetaMaskConnector({}),\n  });\n\n  write();\n}\n```\n\n\n\n4. To test, reload [`http://localhost:3000`](http://localhost:3000), click the \"Follow Me\" button and sign the transaction:\n\n![](/img/content/9aaf1ec-Web3_Social_Media_6.webp)\n\nIf you sign the following transaction, your wallet should then receive a new Lens NFT.",
    "data": {
      "title": "Web3 Social Media",
      "slug": "/guides/web3-social-media",
      "description": "This tutorial teaches you how to create your very own decentralized social profile using [Lens](https://www.lens.xyz/) and the Moralis API.",
      "tags": ["NFT API", "Token API", "Demos"]
    },
    "isEmpty": false,
    "excerpt": ""
  },
  {
    "content": "## Introduction\n\nThis tutorial teaches you how to build a Zapper-like application where you can check Token Balance, Transaction History and NFT balances.\n\n## Prerequisites\n\nBefore getting started, make sure you have the following ready:\n\n- NodeJS v14+\n- A package manager: NPM, Yarn, PNPM\n\n## Step 1: Backend setup\n\n### Initial setup\n\n1. Inside your project root directory, create a new folder that will hold our express backend.\n\n```shell\nmkdir backend\ncd backend\n```\n\n\n\n2. Install the required dependencies.\n\n```bash npm2yarn\nnpm install moralis express cors dotenv nodemon\n```\n\n3. Create a new file with a basic express app inside`backend/index.js`\n\n```javascript index.js\nconst express = require('express')\nconst cors = require('cors')\nconst app = express()\nconst port = 8080\n\napp.use(cors())\n\napp.get('/', (req, res) => {\n  res.send('Hello World!')\n})\n\napp.listen(port, () => {\n  console.log(`Example app listening on port ${port}`)\n})\n```\n\n\n\n4. Add our start script inside `backend/package.json`\n\n```json package.json\n{\n  \"name\": \"zapper\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\",\n    \"start\": \"nodemon index.js\"\n  },\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"dependencies\": {\n    \"cors\": \"^2.8.5\",\n    \"dotenv\": \"^16.0.2\",\n    \"express\": \"^4.18.1\",\n    \"moralis\": \"^2.4.0\",\n    \"nodemon\": \"^2.0.19\"\n  }\n}\n```\n\n\n\n5. Create a `.env` file and add your Moralis API Key inside. You can get your own key following this tutorial [How to get an API Key](/web3-data-api/evm/get-your-api-key).\n\n```typescript .env\nMORALIS_API_KEY = YOUR_KEY_HERE\n```\n\n\n\n6. Now in your `backend/index.js` you can add Moralis.\n\n```javascript index.js\nconst Moralis = require(\"moralis\").default;\nconst express = require(\"express\");\nconst cors = require(\"cors\");\nrequire(\"dotenv\").config();\n\nconst app = express();\nconst port = 8080;\n\napp.use(cors());\n\napp.listen(port, () => {\n  console.log(`Example app listening on port ${port}`);\n});\n```\n\n\n\n### Setup our custom endpoints.\n\nWe can now start adding our endpoints which will be called from our frontend app.\n\n1. Get the native balance.\n\n```javascript index.js\n//GET AMOUNT AND VALUE OF NATIVE TOKENS\n\napp.get(\"/nativeBalance\", async (req, res) => {\n  await Moralis.start({ apiKey: process.env.MORALIS_API_KEY });\n\n  try {\n    const { address, chain } = req.query;\n\n    const response = await Moralis.EvmApi.balance.getNativeBalance({\n      address: address,\n      chain: chain,\n    });\n\n    const nativeBalance = response.data;\n\n    let nativeCurrency;\n    if (chain === \"0x1\") {\n      nativeCurrency = \"0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\";\n    } else if (chain === \"0x89\") {\n      nativeCurrency = \"0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270\";\n    }\n\n    const nativePrice = await Moralis.EvmApi.token.getTokenPrice({\n      address: nativeCurrency, //WETH Contract\n      chain: chain,\n    });\n\n    nativeBalance.usd = nativePrice.data.usdPrice;\n\n    res.send(nativeBalance);\n  } catch (e) {\n    res.send(e);\n  }\n});\n```\n\n\n\n2. Get ERC20 balances and prices.\n\n```javascript index.js\n//GET AMOUNT AND VALUE OF ERC20 TOKENS\n\napp.get(\"/tokenBalances\", async (req, res) => {\n  await Moralis.start({ apiKey: process.env.MORALIS_API_KEY });\n\n  try {\n    const { address, chain } = req.query;\n\n    const response = await Moralis.EvmApi.token.getWalletTokenBalances({\n      address: address,\n      chain: chain,\n    });\n\n    let tokens = response.data;\n    let legitTokens = [];\n    for (let i = 0; i < tokens.length; i++) {\n      try {\n        const priceResponse = await Moralis.EvmApi.token.getTokenPrice({\n          address: tokens[i].token_address,\n          chain: chain,\n        });\n        if (priceResponse.data.usdPrice > 0.01) {\n          tokens[i].usd = priceResponse.data.usdPrice;\n          legitTokens.push(tokens[i]);\n        } else {\n          console.log(\" coin\");\n        }\n      } catch (e) {\n        console.log(e);\n      }\n    }\n\n\n    res.send(legitTokens);\n  } catch (e) {\n    res.send(e);\n  }\n});\n```\n\n\n\n3. Get NFTs.\n\n```javascript index.js\n//GET Users NFT's\n\napp.get(\"/nftBalance\", async (req, res) => {\n  await Moralis.start({ apiKey: process.env.MORALIS_API_KEY });\n\n  try {\n    const { address, chain } = req.query;\n\n    const response = await Moralis.EvmApi.nft.getWalletNFTs({\n      address: address,\n      chain: chain,\n    });\n\n    const userNFTs = response.data;\n\n    res.send(userNFTs);\n  } catch (e) {\n    res.send(e);\n  }\n});\n```\n\n\n\n4. Get historical ERC20 transfers.\n\n```javascript index.js\n//GET USERS TOKEN TRANSFERS\n\napp.get(\"/tokenTransfers\", async (req, res) => {\n  await Moralis.start({ apiKey: process.env.MORALIS_API_KEY });\n\n  try {\n    const { address, chain } = req.query;\n\n    const response = await Moralis.EvmApi.token.getWalletTokenTransfers({\n      address: address,\n      chain: chain,\n    });\n    \n    const userTrans = response.data.result;\n\n    let userTransDetails = [];\n    \n    for (let i = 0; i < userTrans.length; i++) {\n      \n      try {\n        const metaResponse = await Moralis.EvmApi.token.getTokenMetadata({\n          addresses: [userTrans[i].address],\n          chain: chain,\n        });\n        if (metaResponse.data) {\n          userTrans[i].decimals = metaResponse.data[0].decimals;\n          userTrans[i].symbol = metaResponse.data[0].symbol;\n          userTransDetails.push(userTrans[i]);\n        } else {\n          console.log(\"no details for coin\");\n        }\n      } catch (e) {\n        console.log(e);\n      }\n\n    }\n\n\n\n    res.send(userTransDetails);\n  } catch (e) {\n    res.send(e);\n  }\n});\n```\n\n\n\n### Start the express app.\n\n```bash npm2yarn\nnpm run start\n```\n\n## Step 2: Frontend setup\n\n### React app setup\n\nWe will set up a react frontend and start building our UI.\n\nTo style our UI we will be using [Web3uikit](https://github.com/web3ui/web3uikit).\n\n1. Go back to your root directory and create a React application.\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n<Tabs>\n<TabItem value=\"npx\" label=\"npx\">\n\n```shell\nnpx create-react-app frontend\n```\n\n</TabItem>\n<TabItem value=\"yarn\" label=\"Yarn\">\n\n```shell\nyarn create react-app frontend\n```\n\n</TabItem>\n</Tabs>\n\n\n2. Go inside the frontend directory using `cd frontend` and install the required dependencies.\n\n```bash npm2yarn\nnpm install axios @web3uikit/core @web3uikit/web3 @web3uikit/icons\n```\n\n3. Inside the `src` directory, create a new folder that will hold React components. We will call it components.\n\n![](/img/content/65f3f8a-image.webp)\n\n### Creating custom components\n\nInside the components folder, we will create multiple components which will be used inside our React app.\n\n1. NativeTokens.js\n\n```javascript NativeTokens.js\nimport React from \"react\";\nimport axios from \"axios\";\nimport { Table } from \"@web3uikit/core\";\nimport {Reload} from '@web3uikit/icons'\n\n\nfunction NativeTokens({\n  wallet,\n  chain,\n  nativeBalance,\n  setNativeBalance,\n  nativeValue,\n  setNativeValue,\n}) {\n\n\n  async function getNativeBalance() {\n    const response = await axios.get(\"http://localhost:8080/nativeBalance\", {\n      params: {\n        address: wallet,\n        chain: chain,\n      },\n    });\n    if (response.data.balance && response.data.usd) {\n      setNativeBalance((Number(response.data.balance) / 1e18).toFixed(3));\n      setNativeValue(\n        (\n          (Number(response.data.balance) / 1e18) *\n          Number(response.data.usd)\n        ).toFixed(2)\n      );\n    }\n  }\n\n  return (\n    <>\n      <div className=\"tabHeading\">Native Balance <Reload onClick={getNativeBalance}/></div>\n      {(nativeBalance >0 && nativeValue >0) && \n      <Table\n      pageSize={1}\n      noPagination={true}\n      style={{width:\"900px\"}}\n      columnsConfig=\"300px 300px 250px\"\n      data={[[\"Native\", nativeBalance, `$${nativeValue}`]]}\n      header={[\n        <span>Currency</span>,\n        <span>Balance</span>,\n        <span>Value</span>,\n      ]}\n    />\n      }\n      \n    </>\n  );\n}\n\nexport default NativeTokens;\n```\n\n\n\n2. Nfts.js\n\n```javascript Nfts.js\nimport React from \"react\";\nimport axios from \"axios\";\nimport { useState, useEffect } from \"react\";\nimport { Reload } from \"@web3uikit/icons\";\nimport { Input } from \"@web3uikit/core\"\n\nfunction Nfts({ chain, wallet, filteredNfts, setFilteredNfts, nfts, setNfts }) {\n  const [nameFilter, setNameFilter] = useState(\"\");\n  const [idFilter, setIdFilter] = useState(\"\");\n\n  async function getUserNfts() {\n    const response = await axios.get(\"http://localhost:8080/nftBalance\", {\n      params: {\n        address: wallet,\n        chain: chain,\n      },\n    });\n\n    if (response.data.result) {\n      nftProcessing(response.data.result);\n    }\n  }\n\n  function nftProcessing(t) {\n    for (let i = 0; i < t.length; i++) {\n      let meta = JSON.parse(t[i].metadata);\n      if (meta && meta.image) {\n        if (meta.image.includes(\".\")) {\n          t[i].image = meta.image;\n        } else {\n          t[i].image = \"https://ipfs.moralis.io:2053/ipfs/\" + meta.image;\n        }\n      }\n    }\n    setNfts(t);\n    setFilteredNfts(t);\n  }\n\n  useEffect(() => {\n    if (idFilter === \"\" && nameFilter === \"\") {\n      return setFilteredNfts(nfts);\n    }\n\n    let filNfts = [];\n\n    for (let i = 0; i < nfts.length; i++) {\n      if (\n        nfts[i].name.toLowerCase().includes(nameFilter) &&\n        idFilter.length === 0\n      ) {\n        filNfts.push(nfts[i]);\n      } else if (\n        nfts[i].token_id.includes(idFilter) &&\n        nameFilter.length === 0\n      ) {\n        filNfts.push(nfts[i]);\n      } else if (\n        nfts[i].token_id.includes(idFilter) &&\n        nfts[i].name.toLowerCase().includes(nameFilter)\n      ) {\n        filNfts.push(nfts[i]);\n      }\n    }\n\n    setFilteredNfts(filNfts);\n  }, [nameFilter, idFilter]);\n\n  return (\n    <>\n      <div className=\"tabHeading\">\n        NFT Portfolio <Reload onClick={getUserNfts} />\n      </div>\n      <div className= \"filters\">\n      <Input\n          id=\"NameF\"\n          label=\"Name Filter\"\n          labelBgColor=\"rgb(33, 33, 38)\"\n          value={nameFilter}\n          style={{}}\n          onChange={(e) => setNameFilter(e.target.value)}\n        />\n        <Input\n          id=\"IdF\"\n          label=\"Id Filter\"\n          labelBgColor=\"rgb(33, 33, 38)\"\n          value={idFilter}\n          style={{}}\n          onChange={(e) => setIdFilter(e.target.value)}\n        />\n        </div>\n        <div className=\"nftList\">\n        {filteredNfts.length > 0 &&\n        \n          filteredNfts.map((e) => {\n            return (\n              <>\n                <div className=\"nftInfo\">\n                {e.image && <img src={e.image} width={200} />}\n                \n                <div>Name: {e.name}, </div>\n                <div>(ID: {e.token_id.slice(0,5)})</div>\n                </div>\n              </>\n            );\n          })\n          }\n          </div>\n      \n    </>\n  );\n}\n\nexport default Nfts;\n```\n\n\n\n3. PortfolioValue.js\n\n```javascript PortfolioValue.js\nimport React from \"react\";\nimport { useState, useEffect } from \"react\";\nimport \"../App.css\";\n\nfunction PortfolioValue({ tokens, nativeValue }) {\n  const [totalValue, setTotalValue] = useState(0);\n\n\n  useEffect(() => {\n    let val = 0;\n    for (let i = 0; i < tokens.length; i++) {\n      val = val + Number(tokens[i].val);\n    }\n    val = val + Number(nativeValue);\n\n    setTotalValue(val.toFixed(2));\n  }, [nativeValue, tokens]);\n\n  return (\n    <>\n    <div className=\"totalValue\">\n      <h3>Portfolio Total Value</h3>\n      <h2>\n       ${totalValue}\n      </h2>\n    </div>\n    </>\n  );\n}\n\nexport default PortfolioValue;\n```\n\n\n\n4. Tokens.js\n\n```javascript Token.js\nimport React from \"react\";\nimport axios from \"axios\";\nimport { Table } from \"@web3uikit/core\";\nimport { Reload } from \"@web3uikit/icons\";\n\nfunction Tokens({ wallet, chain, tokens, setTokens }) {\n\n  async function getTokenBalances() {\n    const response = await axios.get(\"http://localhost:8080/tokenBalances\", {\n      params: {\n        address: wallet,\n        chain: chain,\n      },\n    });\n\n    if (response.data) {\n      tokenProcessing(response.data);\n    }\n  }\n\n  function tokenProcessing(t) {\n\n    \n    for (let i = 0; i < t.length; i++) {\n      t[i].bal = (Number(t[i].balance) / Number(`1E${t[i].decimals}`)).toFixed(3); //1E18\n      t[i].val = ((Number(t[i].balance) / Number(`1E${t[i].decimals}`)) *Number(t[i].usd)).toFixed(2);\n    }\n\n    setTokens(t);\n\n    \n  }\n\n  return (\n    <>\n      <div className=\"tabHeading\">ERC20 Tokens <Reload onClick={getTokenBalances}/></div>\n\n      {tokens.length > 0 && (\n        <Table\n          pageSize={6}\n          noPagination={true}\n          style={{ width: \"900px\" }}\n          columnsConfig=\"300px 300px 250px\"\n          data={tokens.map((e) => [e.symbol, e.bal, `$${e.val}`] )}\n          header={[\n            <span>Currency</span>,\n            <span>Balance</span>,\n            <span>Value</span>,\n          ]}\n        />\n      )}\n    </>\n  );\n}\n\nexport default Tokens;\n```\n\n\n\n5. TransferHistory.js\n\n```javascript TransferHistory.js\nimport React from \"react\";\nimport axios from \"axios\";\nimport { Reload } from \"@web3uikit/icons\";\nimport { Table } from \"@web3uikit/core\";\n\nfunction TransferHistory({ chain, wallet, transfers, setTransfers }) {\n  async function getTokenTransfers() {\n    const response = await axios.get(\"http://localhost:8080/tokenTransfers\", {\n      params: {\n        address: wallet,\n        chain: chain,\n      },\n    });\n\n    if (response.data) {\n      setTransfers(response.data);\n      console.log(response.data);\n    }\n  }\n\n\n  return (\n    <>\n      <div className=\"tabHeading\">\n        Transfer History <Reload onClick={getTokenTransfers} />\n      </div>\n      <div>\n        {transfers.length > 0 && (\n          <Table\n            pageSize={8}\n            noPagination={false}\n            style={{ width: \"90vw\" }}\n            columnsConfig=\"16vw 18vw 18vw 18vw 16vw\"\n            data={transfers.map((e) => [\n              e.symbol,\n              (Number(e.value) / Number(`1e${e.decimals}`)).toFixed(3),\n              `${e.from_address.slice(0, 4)}...${e.from_address.slice(38)}`,\n              `${e.to_address.slice(0, 4)}...${e.to_address.slice(38)}`,\n              e.block_timestamp.slice(0,10),\n            ])}\n            header={[\n              <span>Token</span>,\n              <span>Amount</span>,\n              <span>From</span>,\n              <span>To</span>,\n              <span>Date</span>,\n            ]}\n          />\n        )}\n      </div>\n    </>\n  );\n}\n\nexport default TransferHistory;\n```\n\n\n\n6. WalletInputs.js\n\n```javascript WalletInputs.js\nimport React from \"react\";\nimport \"../App.css\";\nimport {Input, Select, CryptoLogos} from '@web3uikit/core'\n\nfunction WalletInputs({chain, wallet, setChain, setWallet}) {\n  return (\n    <>\n    <div className=\"header\">\n      <div className=\"title\">\n        <svg width=\"40\" height=\"40\" viewBox=\"0 0 500 500\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path id=\"logo_exterior\" d=\"M500 250C500 111.929 388.071 0 250 0C111.929 0 0 111.929 0 250C0 388.071 111.929 500 250 500C388.071 500 500 388.071 500 250Z\" fill=\"#784FFE\"></path><path id=\"logo_interior\" fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M154.338 187.869L330.605 187L288.404 250.6L388 250.118L345.792 312.652L168.382 313.787L211.25 250.633L112 250.595L154.338 187.869Z\" fill=\"white\"></path></svg>\n        <h1>Zapper</h1>\n      </div>\n      <div className=\"walletInputs\">\n        <Input\n          id=\"Wallet\"\n          label=\"Wallet Address\"\n          labelBgColor=\"rgb(33, 33, 38)\"\n          value={wallet}\n          style={{height: \"50px\"}}\n          onChange={(e) => setWallet(e.target.value)}\n        />\n        <Select\n          defaultOptionIndex={0}\n          id=\"Chain\"\n          onChange={(e) => setChain(e.value)}\n          options={[\n          {\n            id: 'eth',\n            label: 'Ethereum',\n            value: \"0x1\",\n            prefix: <CryptoLogos chain=\"ethereum\"/>\n          },\n          {\n            id: 'matic',\n            label: 'Polygon',\n            value: \"0x89\",\n            prefix: <CryptoLogos chain=\"polygon\"/>\n          },\n          ]}\n        />\n      </div>\n    </div>\n    </>\n  );\n}\n\nexport default WalletInputs;\n```\n\n\n\n### Import our components\n\nNow we have to import everything inside `App.js`\n\n```javascript App.js\nimport \"./App.css\";\nimport { useState } from \"react\";\nimport NativeTokens from \"./components/NativeTokens\";\nimport Tokens from \"./components/Tokens\";\nimport TransferHistory from \"./components/TransferHistory\";\nimport Nfts from \"./components/Nfts\";\nimport WalletInputs from \"./components/WalletInputs\";\nimport PortfolioValue from \"./components/PortfolioValue\";\nimport { Avatar, TabList, Tab } from \"@web3uikit/core\";\n\nfunction App() {\n  const [wallet, setWallet] = useState(\"\");\n  const [chain, setChain] = useState(\"0x1\");\n  const [nativeBalance, setNativeBalance] = useState(0);\n  const [nativeValue, setNativeValue] = useState(0);\n  const [tokens, setTokens] = useState([]);\n  const [nfts, setNfts] = useState([]);\n  const [filteredNfts, setFilteredNfts] = useState([]);\n  const [transfers, setTransfers] = useState([]);\n\n\n  return (\n    <div className=\"App\">\n      <WalletInputs\n        chain={chain}\n        setChain={setChain}\n        wallet={wallet}\n        setWallet={setWallet}\n      />\n      <div className=\"content\">\n        <div className=\"walletInfo\">\n          {wallet.length === 42 && (\n            <>\n              <div>\n                <Avatar isRounded size={130} theme=\"image\" />\n                <h2>{`${wallet.slice(0, 6)}...${wallet.slice(36)}`}</h2>\n              </div>\n              <PortfolioValue\n                nativeValue={nativeValue}\n                tokens={tokens}\n              />\n            </>\n          )}\n        </div>\n\n        <TabList>\n          <Tab tabKey={1} tabName={\"Tokens\"}>\n            <NativeTokens\n              wallet={wallet}\n              chain={chain}\n              nativeBalance={nativeBalance}\n              setNativeBalance={setNativeBalance}\n              nativeValue={nativeValue}\n              setNativeValue={setNativeValue}\n            />\n            <Tokens\n              wallet={wallet}\n              chain={chain}\n              tokens={tokens}\n              setTokens={setTokens}\n            />\n          </Tab>\n          <Tab tabKey={2} tabName={\"Transfers\"}>\n            <TransferHistory \n              chain={chain} \n              wallet={wallet} \n              transfers={transfers}\n              setTransfers={setTransfers}\n            />\n          </Tab>\n          <Tab tabKey={3} tabName={\"NFT's\"}>\n            <Nfts \n              wallet={wallet} \n              chain={chain} \n              nfts={nfts}\n              setNfts={setNfts}\n              filteredNfts={filteredNfts}\n              setFilteredNfts={setFilteredNfts}  \n            />\n          </Tab>\n        </TabList>\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n```\n\n\n\n## Step 3: Frontend styling\n\nWe will now add the required CSS style for our app.\n\n1. Inside our `src/App.css` add the following styles.\n\n```css App.css\n.App {\n  text-align: left;\n  min-height: 100vh;\n}\n\n.header {\n  height: 80px;\n  width: calc(100vw - 100px);\n  display: flex;\n  justify-content: flex-start;\n  background-color: rgb(33, 33, 38);\n  border-bottom: 1px solid rgb(121, 121, 121);\n  padding: 5px 50px;\n  align-items: center;\n}\n\n.title {\n  display: flex;\n  height: 60px;\n  align-items: center;\n  gap: 25px;\n}\n\n.walletInputs {\n  display: flex;\n  justify-content: flex-end;\n  width: 100%;\n  align-items: center;\n  gap: 25px;\n}\n\n.content {\n  height: 100%;\n  margin: 0;\n  padding: 100px;\n  background: linear-gradient(180deg, rgba(142, 211, 182, 0.3) 0%, rgba(36,20,0,0) 50%);\n}\n\n.walletInfo {\n  display: flex;\n  justify-content: space-between;\n}\n\n.totalValue {\n  width: 350px;\n  height: 150px;\n  padding: 10px 30px; \n  border-radius: 20px;\n  background-color: rgba(33, 33, 38, 0.6);\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n}\n\n.tabHeading {\n  font-size: 30px;\n  font-weight: bold;\n  margin: 20px 0px;\n  align-items: center;\n  display: flex;\n  gap: 20px;\n}\n\n.filters {\n  display: flex;\n  gap: 20px;\n  margin: 30px 0px;\n}\n\n.nftInfo {\n  justify-content: center;\n  align-items: center;\n  display: flex;\n  flex-direction: column;\n  color: white;\n  gap: 5px;\n  background-color: rgb(42, 42, 47);\n  border-radius: 5px;\n  padding: 10px;\n}\n\n.nftList {\n  display: flex;\n  justify-content: flex-start;\n  gap: 40px;\n  flex-wrap: wrap;\n}\n```\n\n\n\n2. Inside `src/index.css` add the following:\n\n```css index.css\nbody {\n  margin: 0;\n  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',\n    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',\n    sans-serif;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  background-color: rgb(33, 33, 38);\n  color: white;\n}\n\ncode {\n  font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',\n    monospace;\n}\n```\n\n\n\n## Step 4: Start the app\n\nWe can now start our React app and check everything we have built.\n\n1. Run the start script inside the frontend directory.\n\n```bash npm2yarn\nnpm run start\n```\n\n2. You can now access `<http://localhost:3000/`> and should see your app running.\n\n![](/img/content/1d5da92-image.webp)\n\n## Youtube Video\n\nhttps://www.youtube.com/watch?v=C9yA8LcJsIY\n",
    "data": {
      "title": "Zapper Clone",
      "slug": "/guides/zapper-clone",
      "description": "This tutorial teaches you how to build a Zapper-like application where you can check Token Balance, Transaction History and NFT balances.",
      "tags": ["NFT API", "Token API", "Balance API", "Demos"]
    },
    "isEmpty": false,
    "excerpt": ""
  }
]
